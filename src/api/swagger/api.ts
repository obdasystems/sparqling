/* tslint:disable */
/* eslint-disable */
/**
 * Swagger Sparqling WS
 * This server will expose an API to Sparqling front end to create new SPARQL queries with a combinations of point and click on the [GRAPHOLscape](https://github.com/obdasystems/grapholscape) graph.  Sparqling will be released as a standalone appication but also the server will embedded in [MWS](https://github.com/obdasystems/mws) and Sparqling will be integrated in [Monolith](https://www.monolith.obdasystems.com/).
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: info@obdasystems.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Branch
 */
export interface Branch {
    /**
     * 
     * @type {string}
     * @memberof Branch
     */
    'objectPropertyIRI'?: string;
    /**
     * It is true when domain and range are the same class.
     * @type {boolean}
     * @memberof Branch
     */
    'cyclic'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Branch
     */
    'direct'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof Branch
     */
    'relatedClasses'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Entity
 */
export interface Entity {
    /**
     * 
     * @type {string}
     * @memberof Entity
     */
    'type'?: EntityTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Entity
     */
    'iri'?: string;
    /**
     * 
     * @type {string}
     * @memberof Entity
     */
    'prefixedIri'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Entity
     */
    'labels'?: { [key: string]: string; };
}

export const EntityTypeEnum = {
    Class: 'class',
    ObjectProperty: 'objectProperty',
    InverseObjectProperty: 'inverseObjectProperty',
    DataProperty: 'dataProperty'
} as const;

export type EntityTypeEnum = typeof EntityTypeEnum[keyof typeof EntityTypeEnum];

/**
 * 
 * @export
 * @interface Filter
 */
export interface Filter {
    /**
     * 
     * @type {FilterExpression}
     * @memberof Filter
     */
    'expression'?: FilterExpression;
}
/**
 * 
 * @export
 * @interface FilterExpression
 */
export interface FilterExpression {
    /**
     * 
     * @type {string}
     * @memberof FilterExpression
     */
    'operator'?: FilterExpressionOperatorEnum;
    /**
     * 
     * @type {Array<VarOrConstant>}
     * @memberof FilterExpression
     */
    'parameters'?: Array<VarOrConstant>;
}

export const FilterExpressionOperatorEnum = {
    Equal: '=',
    NotEqual: '!=',
    LessThan: '<',
    GreaterThan: '>',
    LessThanOrEqualTo: '<=',
    GreaterThanOrEqualTo: '>=',
    In: 'IN',
    NotIn: 'NOT IN',
    Regex: 'REGEX'
} as const;

export type FilterExpressionOperatorEnum = typeof FilterExpressionOperatorEnum[keyof typeof FilterExpressionOperatorEnum];

/**
 * 
 * @export
 * @interface Function
 */
export interface Function {
    /**
     * 
     * @type {string}
     * @memberof Function
     */
    'name'?: FunctionNameEnum;
    /**
     * 
     * @type {Array<VarOrConstant>}
     * @memberof Function
     */
    'parameters'?: Array<VarOrConstant>;
}

export const FunctionNameEnum = {
    Add: 'ADD',
    Subctract: 'SUBCTRACT',
    Multiply: 'MULTIPLY',
    Divide: 'DIVIDE',
    Substr: 'SUBSTR',
    Ucase: 'UCASE',
    Lcase: 'LCASE',
    Contains: 'CONTAINS',
    Concat: 'CONCAT',
    Round: 'ROUND',
    Ceil: 'CEIL',
    Floor: 'FLOOR',
    Year: 'YEAR',
    Month: 'MONTH',
    Day: 'DAY',
    Hours: 'HOURS',
    Minutes: 'MINUTES',
    Seconds: 'SECONDS'
} as const;

export type FunctionNameEnum = typeof FunctionNameEnum[keyof typeof FunctionNameEnum];

/**
 * 
 * @export
 * @interface GraphElement
 */
export interface GraphElement {
    /**
     * This id corrensopond to the variable when entity type is a class.
     * @type {string}
     * @memberof GraphElement
     */
    'id'?: string;
    /**
     * This element could refer to one variable (if it\'s a class) or to two variables (if it\'s a property)
     * @type {Array<string>}
     * @memberof GraphElement
     */
    'variables'?: Array<string>;
    /**
     * It could have more than one entity only when entity type is a class (could be derived after clicking on two borther classes)
     * @type {Array<Entity>}
     * @memberof GraphElement
     */
    'entities'?: Array<Entity>;
    /**
     * 
     * @type {Array<GraphElement>}
     * @memberof GraphElement
     */
    'children'?: Array<GraphElement>;
}
/**
 * 
 * @export
 * @interface GroupByElement
 */
export interface GroupByElement {
    /**
     * 
     * @type {boolean}
     * @memberof GroupByElement
     */
    'distinct'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GroupByElement
     */
    'aggregateFunction'?: GroupByElementAggregateFunctionEnum;
}

export const GroupByElementAggregateFunctionEnum = {
    Count: 'count',
    Sum: 'sum',
    Min: 'min',
    Max: 'max',
    Avarage: 'avarage'
} as const;

export type GroupByElementAggregateFunctionEnum = typeof GroupByElementAggregateFunctionEnum[keyof typeof GroupByElementAggregateFunctionEnum];

/**
 * 
 * @export
 * @interface HeadElement
 */
export interface HeadElement {
    /**
     * 
     * @type {string}
     * @memberof HeadElement
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof HeadElement
     */
    'graphElementId'?: string;
    /**
     * 
     * @type {string}
     * @memberof HeadElement
     */
    'var'?: string;
    /**
     * 
     * @type {string}
     * @memberof HeadElement
     */
    'alias'?: string;
    /**
     * 1 is ascending -1 descending 0 not defined
     * @type {number}
     * @memberof HeadElement
     */
    'ordering'?: number;
    /**
     * 
     * @type {Function}
     * @memberof HeadElement
     */
    'function'?: Function;
    /**
     * 
     * @type {GroupByElement}
     * @memberof HeadElement
     */
    'groupBy'?: GroupByElement;
    /**
     * 
     * @type {Array<Filter>}
     * @memberof HeadElement
     */
    'having'?: Array<Filter>;
}
/**
 * 
 * @export
 * @interface Highlights
 */
export interface Highlights {
    /**
     * Subclasses or brother classes
     * @type {Array<string>}
     * @memberof Highlights
     */
    'classes'?: Array<string>;
    /**
     * 
     * @type {Array<Branch>}
     * @memberof Highlights
     */
    'objectProperties'?: Array<Branch>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Highlights
     */
    'dataProperties'?: Array<string>;
}
/**
 * 
 * @export
 * @interface OntologyPath
 */
export interface OntologyPath {
    /**
     * Starts with lastSelectedIRI and ends with clickedIRI. In between the nodes and edges traversed in the path (ISA edge are marked as ISA)
     * @type {Array<string>}
     * @memberof OntologyPath
     */
    'entities'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Optional
 */
export interface Optional {
    /**
     * 
     * @type {number}
     * @memberof Optional
     */
    'id'?: number;
    /**
     * Path of ids that describe optional.
     * @type {Array<string>}
     * @memberof Optional
     */
    'graphIds'?: Array<string>;
}
/**
 * 
 * @export
 * @interface QueryGraph
 */
export interface QueryGraph {
    /**
     * 
     * @type {boolean}
     * @memberof QueryGraph
     */
    'distinct'?: boolean;
    /**
     * 
     * @type {Array<HeadElement>}
     * @memberof QueryGraph
     */
    'head': Array<HeadElement>;
    /**
     * 
     * @type {GraphElement}
     * @memberof QueryGraph
     */
    'graph': GraphElement;
    /**
     * 
     * @type {Array<Filter>}
     * @memberof QueryGraph
     */
    'filters'?: Array<Filter>;
    /**
     * 
     * @type {Array<Optional>}
     * @memberof QueryGraph
     */
    'optionals'?: Array<Optional>;
    /**
     * 
     * @type {number}
     * @memberof QueryGraph
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof QueryGraph
     */
    'offset'?: number;
    /**
     * 
     * @type {string}
     * @memberof QueryGraph
     */
    'sparql': string;
}
/**
 * 
 * @export
 * @interface VarOrConstant
 */
export interface VarOrConstant {
    /**
     * 
     * @type {string}
     * @memberof VarOrConstant
     */
    'type'?: VarOrConstantTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof VarOrConstant
     */
    'value'?: string;
    /**
     * 
     * @type {string}
     * @memberof VarOrConstant
     */
    'constantType'?: VarOrConstantConstantTypeEnum;
}

export const VarOrConstantTypeEnum = {
    Var: 'var',
    Constant: 'constant',
    Iri: 'iri'
} as const;

export type VarOrConstantTypeEnum = typeof VarOrConstantTypeEnum[keyof typeof VarOrConstantTypeEnum];
export const VarOrConstantConstantTypeEnum = {
    String: 'xsd:string',
    Decimal: 'xsd:decimal',
    DateTime: 'xsd:dateTime'
} as const;

export type VarOrConstantConstantTypeEnum = typeof VarOrConstantConstantTypeEnum[keyof typeof VarOrConstantConstantTypeEnum];


/**
 * OntologyGraphApi - axios parameter creator
 * @export
 */
export const OntologyGraphApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This route is used to highlight the negihbours of the selected class. The neighbours can be classes (brother classes or child classes), object properties (the class or one of his father partecipate or are typed to domain/range) or data properties (the class or one of its fathers partecipates or is typed to its domain).
         * @summary Get the IRIs of the ontology entities \"related\" to the clicked and selected.
         * @param {string} clickedClassIRI The IRI of the class just clicked on the GRAPHOLscape ontology graph
         * @param {Array<string>} [params] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        highligths: async (clickedClassIRI: string, params?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clickedClassIRI' is not null or undefined
            assertParamExists('highligths', 'clickedClassIRI', clickedClassIRI)
            const localVarPath = `/highlights`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (clickedClassIRI !== undefined) {
                localVarQueryParameter['clickedClassIRI'] = clickedClassIRI;
            }

            if (params) {
                localVarQueryParameter['params'] = params;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The results should be based on Dijkstra algorithm for shortest paths. ISA wieght is 0 while role weight is 1.
         * @summary Find paths between selected class and clicked class.
         * @param {string} lastSelectedIRI The IRI of the entity clicked on the GRAPHOLscape ontology graph
         * @param {string} clickedIRI The IRI of the entity clicked on the GRAPHOLscape ontology graph
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        highligthsPaths: async (lastSelectedIRI: string, clickedIRI: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'lastSelectedIRI' is not null or undefined
            assertParamExists('highligthsPaths', 'lastSelectedIRI', lastSelectedIRI)
            // verify required parameter 'clickedIRI' is not null or undefined
            assertParamExists('highligthsPaths', 'clickedIRI', clickedIRI)
            const localVarPath = `/highlights/paths`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (lastSelectedIRI !== undefined) {
                localVarQueryParameter['lastSelectedIRI'] = lastSelectedIRI;
            }

            if (clickedIRI !== undefined) {
                localVarQueryParameter['clickedIRI'] = clickedIRI;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OntologyGraphApi - functional programming interface
 * @export
 */
export const OntologyGraphApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OntologyGraphApiAxiosParamCreator(configuration)
    return {
        /**
         * This route is used to highlight the negihbours of the selected class. The neighbours can be classes (brother classes or child classes), object properties (the class or one of his father partecipate or are typed to domain/range) or data properties (the class or one of its fathers partecipates or is typed to its domain).
         * @summary Get the IRIs of the ontology entities \"related\" to the clicked and selected.
         * @param {string} clickedClassIRI The IRI of the class just clicked on the GRAPHOLscape ontology graph
         * @param {Array<string>} [params] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async highligths(clickedClassIRI: string, params?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Highlights>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.highligths(clickedClassIRI, params, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The results should be based on Dijkstra algorithm for shortest paths. ISA wieght is 0 while role weight is 1.
         * @summary Find paths between selected class and clicked class.
         * @param {string} lastSelectedIRI The IRI of the entity clicked on the GRAPHOLscape ontology graph
         * @param {string} clickedIRI The IRI of the entity clicked on the GRAPHOLscape ontology graph
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async highligthsPaths(lastSelectedIRI: string, clickedIRI: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OntologyPath>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.highligthsPaths(lastSelectedIRI, clickedIRI, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OntologyGraphApi - factory interface
 * @export
 */
export const OntologyGraphApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OntologyGraphApiFp(configuration)
    return {
        /**
         * This route is used to highlight the negihbours of the selected class. The neighbours can be classes (brother classes or child classes), object properties (the class or one of his father partecipate or are typed to domain/range) or data properties (the class or one of its fathers partecipates or is typed to its domain).
         * @summary Get the IRIs of the ontology entities \"related\" to the clicked and selected.
         * @param {string} clickedClassIRI The IRI of the class just clicked on the GRAPHOLscape ontology graph
         * @param {Array<string>} [params] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        highligths(clickedClassIRI: string, params?: Array<string>, options?: any): AxiosPromise<Highlights> {
            return localVarFp.highligths(clickedClassIRI, params, options).then((request) => request(axios, basePath));
        },
        /**
         * The results should be based on Dijkstra algorithm for shortest paths. ISA wieght is 0 while role weight is 1.
         * @summary Find paths between selected class and clicked class.
         * @param {string} lastSelectedIRI The IRI of the entity clicked on the GRAPHOLscape ontology graph
         * @param {string} clickedIRI The IRI of the entity clicked on the GRAPHOLscape ontology graph
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        highligthsPaths(lastSelectedIRI: string, clickedIRI: string, options?: any): AxiosPromise<Array<OntologyPath>> {
            return localVarFp.highligthsPaths(lastSelectedIRI, clickedIRI, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OntologyGraphApi - object-oriented interface
 * @export
 * @class OntologyGraphApi
 * @extends {BaseAPI}
 */
export class OntologyGraphApi extends BaseAPI {
    /**
     * This route is used to highlight the negihbours of the selected class. The neighbours can be classes (brother classes or child classes), object properties (the class or one of his father partecipate or are typed to domain/range) or data properties (the class or one of its fathers partecipates or is typed to its domain).
     * @summary Get the IRIs of the ontology entities \"related\" to the clicked and selected.
     * @param {string} clickedClassIRI The IRI of the class just clicked on the GRAPHOLscape ontology graph
     * @param {Array<string>} [params] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyGraphApi
     */
    public highligths(clickedClassIRI: string, params?: Array<string>, options?: AxiosRequestConfig) {
        return OntologyGraphApiFp(this.configuration).highligths(clickedClassIRI, params, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The results should be based on Dijkstra algorithm for shortest paths. ISA wieght is 0 while role weight is 1.
     * @summary Find paths between selected class and clicked class.
     * @param {string} lastSelectedIRI The IRI of the entity clicked on the GRAPHOLscape ontology graph
     * @param {string} clickedIRI The IRI of the entity clicked on the GRAPHOLscape ontology graph
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyGraphApi
     */
    public highligthsPaths(lastSelectedIRI: string, clickedIRI: string, options?: AxiosRequestConfig) {
        return OntologyGraphApiFp(this.configuration).highligthsPaths(lastSelectedIRI, clickedIRI, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * QueryGraphBGPApi - axios parameter creator
 * @export
 */
export const QueryGraphBGPApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This path should be used to build the query graph using the path interaction. As a result there will be added to the query several triple pattern (depending on the length of the path) as a sequence of classes and object properties. Data properties never appear in paths, in order to add them use the simple PUT route.
         * @summary Get the query graph that will be rendered by Sparqling, the query head, the sparql code based on the chosen path.
         * @param {string} path Serialization of Path object.
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPathToQueryGraph: async (path: string, queryGraph: QueryGraph, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'path' is not null or undefined
            assertParamExists('addPathToQueryGraph', 'path', path)
            // verify required parameter 'queryGraph' is not null or undefined
            assertParamExists('addPathToQueryGraph', 'queryGraph', queryGraph)
            const localVarPath = `/queryGraph/path`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(queryGraph, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This route is used when the user wants to delete a node from the query graph. All the children of this node will be deleted as well as we do not want to create query with completly separated branches. All the variables that are going to be deleted should also be deleted from the head of the query. **WARNING**, if the node has multiple occurrences (due to join operations) every node should be deleted.
         * @summary Delete the GraphElement (and all its children) from the query graph and head.
         * @param {string} graphElementId The GraphElement that should be deleted
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGraphElementId: async (graphElementId: string, queryGraph: QueryGraph, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'graphElementId' is not null or undefined
            assertParamExists('deleteGraphElementId', 'graphElementId', graphElementId)
            // verify required parameter 'queryGraph' is not null or undefined
            assertParamExists('deleteGraphElementId', 'queryGraph', queryGraph)
            const localVarPath = `/queryGraph/node/delete/{graphElementId}`
                .replace(`{${"graphElementId"}}`, encodeURIComponent(String(graphElementId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(queryGraph, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete from GraphElement only the class
         * @param {string} graphElementId 
         * @param {string} classIRI The class that should be deleted
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGraphElementIdClass: async (graphElementId: string, classIRI: string, queryGraph: QueryGraph, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'graphElementId' is not null or undefined
            assertParamExists('deleteGraphElementIdClass', 'graphElementId', graphElementId)
            // verify required parameter 'classIRI' is not null or undefined
            assertParamExists('deleteGraphElementIdClass', 'classIRI', classIRI)
            // verify required parameter 'queryGraph' is not null or undefined
            assertParamExists('deleteGraphElementIdClass', 'queryGraph', queryGraph)
            const localVarPath = `/queryGraph/node/delete/{graphElementId}/class`
                .replace(`{${"graphElementId"}}`, encodeURIComponent(String(graphElementId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (classIRI !== undefined) {
                localVarQueryParameter['classIRI'] = classIRI;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(queryGraph, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Starting from only the clicked class get the query graph that will be rendered by Sparqling, the query head, the sparql code. The sparql query returned will be somthing like `select ?x { ?x a <clickedClassIRI>` }. The variable `?x` should be called according to the entity remainder or label. The variable will be added to the head of the query in order to create a valid SPARQL query.
         * @summary This is the first route to call in order to build the query graph.
         * @param {string} clickedClassIRI The IRI of the entity clicked on the GRAPHOLscape ontology graph
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueryGraph: async (clickedClassIRI: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clickedClassIRI' is not null or undefined
            assertParamExists('getQueryGraph', 'clickedClassIRI', clickedClassIRI)
            const localVarPath = `/queryGraph/node`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (clickedClassIRI !== undefined) {
                localVarQueryParameter['clickedClassIRI'] = clickedClassIRI;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This call is used when the user click on a highlighted class and should add a triple pattern of the form like `?x rdf:type <targetClassIRI>`. The server should find `?x` in the SPARQL code as the variable associated to the `sourceClassIRI`.
         * @summary Starting from the current query graph continue to build the query graph through a class.
         * @param {string} graphElementId The id of the node of the selected class in the query graph.
         * @param {string} sourceClassIRI The IRI of the last selected class. It could be selected from the ontology graph or from the query graph.
         * @param {string} targetClassIRI The IRI of the entity clicked on the GRAPHOLscape ontology graph.
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putQueryGraphClass: async (graphElementId: string, sourceClassIRI: string, targetClassIRI: string, queryGraph: QueryGraph, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'graphElementId' is not null or undefined
            assertParamExists('putQueryGraphClass', 'graphElementId', graphElementId)
            // verify required parameter 'sourceClassIRI' is not null or undefined
            assertParamExists('putQueryGraphClass', 'sourceClassIRI', sourceClassIRI)
            // verify required parameter 'targetClassIRI' is not null or undefined
            assertParamExists('putQueryGraphClass', 'targetClassIRI', targetClassIRI)
            // verify required parameter 'queryGraph' is not null or undefined
            assertParamExists('putQueryGraphClass', 'queryGraph', queryGraph)
            const localVarPath = `/queryGraph/node/class/{graphElementId}`
                .replace(`{${"graphElementId"}}`, encodeURIComponent(String(graphElementId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sourceClassIRI !== undefined) {
                localVarQueryParameter['sourceClassIRI'] = sourceClassIRI;
            }

            if (targetClassIRI !== undefined) {
                localVarQueryParameter['targetClassIRI'] = targetClassIRI;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(queryGraph, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This route is used when the user click a highlighted data property. The triple pattern to add is something like `?x <predicateIRI> ?y` where `?x` should be derived from `selectedClassIRI`. Note that `?y` is fresh new variable that should be added also to the head of the query (we assume data property values are interesting). The variable `?y` should be called according to the entity remainder or label and should add a counter if there is an already defined variable for that data property.
         * @summary Starting from the current query graph continue to build the query graph through a data property.
         * @param {string} graphElementId The id of the node of the selected class in the query graph.
         * @param {string} sourceClassIRI The IRI of the last selected class. It could be selected from the ontology graph or from the query graph.
         * @param {string} predicateIRI The IRI of the clicked data property.
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putQueryGraphDataProperty: async (graphElementId: string, sourceClassIRI: string, predicateIRI: string, queryGraph: QueryGraph, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'graphElementId' is not null or undefined
            assertParamExists('putQueryGraphDataProperty', 'graphElementId', graphElementId)
            // verify required parameter 'sourceClassIRI' is not null or undefined
            assertParamExists('putQueryGraphDataProperty', 'sourceClassIRI', sourceClassIRI)
            // verify required parameter 'predicateIRI' is not null or undefined
            assertParamExists('putQueryGraphDataProperty', 'predicateIRI', predicateIRI)
            // verify required parameter 'queryGraph' is not null or undefined
            assertParamExists('putQueryGraphDataProperty', 'queryGraph', queryGraph)
            const localVarPath = `/queryGraph/node/dataProperty/{graphElementId}`
                .replace(`{${"graphElementId"}}`, encodeURIComponent(String(graphElementId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sourceClassIRI !== undefined) {
                localVarQueryParameter['sourceClassIRI'] = sourceClassIRI;
            }

            if (predicateIRI !== undefined) {
                localVarQueryParameter['predicateIRI'] = predicateIRI;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(queryGraph, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Starting from a query graph which has two nodes representing the same class(es), it returns the query graph in which the two nodes have been joined into a single one. The children of the selected nodes will be grouped in `graphElementId1` and each time we add a children through the previous routes they will be added to this node.
         * @summary Join two GraphNodeElement in one.
         * @param {string} graphElementId1 The id of the node of the selected class in the query graph.
         * @param {string} graphElementId2 The id of the node of the selected class in the query graph.
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putQueryGraphJoin: async (graphElementId1: string, graphElementId2: string, queryGraph: QueryGraph, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'graphElementId1' is not null or undefined
            assertParamExists('putQueryGraphJoin', 'graphElementId1', graphElementId1)
            // verify required parameter 'graphElementId2' is not null or undefined
            assertParamExists('putQueryGraphJoin', 'graphElementId2', graphElementId2)
            // verify required parameter 'queryGraph' is not null or undefined
            assertParamExists('putQueryGraphJoin', 'queryGraph', queryGraph)
            const localVarPath = `/queryGraph/node/join/{graphElementId1}/{graphElementId2}`
                .replace(`{${"graphElementId1"}}`, encodeURIComponent(String(graphElementId1)))
                .replace(`{${"graphElementId2"}}`, encodeURIComponent(String(graphElementId2)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(queryGraph, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This route is used when the user click a highlighted object property with ornly one `relatedClasses` or, in the case of more than one `relatedClasses` immediatly after choosing one of them. In this case the triple pattern to add is something like `?x <predicateIRI> ?y` where `?x` and `?y` should be derived from the direction indicated by `isPredicateDirect` of the object property with respect to `sourceClassIRI` and `targetClassIRI`. If there is a cyclic object property the user also should specify the direction if order to correctly assign `?x` and `?y`. Either `?x` or `?y` should be a fresh new variable which should be linked to a new triple pattern `?y rdf:type <targetClassIRI>`. The variable `?y` should be called according to the entity remainder or label and should add a counter if there is an already defined variable for that class.
         * @summary Starting from the current query graph continue to build the query graph through a object property.
         * @param {string} graphElementId The id of the node of the selected class in the query graph.
         * @param {string} sourceClassIRI The IRI of the last selected class. It could be selected from the ontology graph or from the query graph.
         * @param {string} predicateIRI The IRI of the predicate which links source class and target class
         * @param {string} targetClassIRI The IRI of the entity clicked on the GRAPHOLscape ontology graph.
         * @param {boolean} isPredicateDirect If true sourceClassIRI is the domain of predicateIRI, if false sourceClassIRI is the range of predicateIRI.
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putQueryGraphObjectProperty: async (graphElementId: string, sourceClassIRI: string, predicateIRI: string, targetClassIRI: string, isPredicateDirect: boolean, queryGraph: QueryGraph, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'graphElementId' is not null or undefined
            assertParamExists('putQueryGraphObjectProperty', 'graphElementId', graphElementId)
            // verify required parameter 'sourceClassIRI' is not null or undefined
            assertParamExists('putQueryGraphObjectProperty', 'sourceClassIRI', sourceClassIRI)
            // verify required parameter 'predicateIRI' is not null or undefined
            assertParamExists('putQueryGraphObjectProperty', 'predicateIRI', predicateIRI)
            // verify required parameter 'targetClassIRI' is not null or undefined
            assertParamExists('putQueryGraphObjectProperty', 'targetClassIRI', targetClassIRI)
            // verify required parameter 'isPredicateDirect' is not null or undefined
            assertParamExists('putQueryGraphObjectProperty', 'isPredicateDirect', isPredicateDirect)
            // verify required parameter 'queryGraph' is not null or undefined
            assertParamExists('putQueryGraphObjectProperty', 'queryGraph', queryGraph)
            const localVarPath = `/queryGraph/node/objectProperty/{graphElementId}`
                .replace(`{${"graphElementId"}}`, encodeURIComponent(String(graphElementId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sourceClassIRI !== undefined) {
                localVarQueryParameter['sourceClassIRI'] = sourceClassIRI;
            }

            if (predicateIRI !== undefined) {
                localVarQueryParameter['predicateIRI'] = predicateIRI;
            }

            if (targetClassIRI !== undefined) {
                localVarQueryParameter['targetClassIRI'] = targetClassIRI;
            }

            if (isPredicateDirect !== undefined) {
                localVarQueryParameter['isPredicateDirect'] = isPredicateDirect;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(queryGraph, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QueryGraphBGPApi - functional programming interface
 * @export
 */
export const QueryGraphBGPApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QueryGraphBGPApiAxiosParamCreator(configuration)
    return {
        /**
         * This path should be used to build the query graph using the path interaction. As a result there will be added to the query several triple pattern (depending on the length of the path) as a sequence of classes and object properties. Data properties never appear in paths, in order to add them use the simple PUT route.
         * @summary Get the query graph that will be rendered by Sparqling, the query head, the sparql code based on the chosen path.
         * @param {string} path Serialization of Path object.
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addPathToQueryGraph(path: string, queryGraph: QueryGraph, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryGraph>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addPathToQueryGraph(path, queryGraph, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This route is used when the user wants to delete a node from the query graph. All the children of this node will be deleted as well as we do not want to create query with completly separated branches. All the variables that are going to be deleted should also be deleted from the head of the query. **WARNING**, if the node has multiple occurrences (due to join operations) every node should be deleted.
         * @summary Delete the GraphElement (and all its children) from the query graph and head.
         * @param {string} graphElementId The GraphElement that should be deleted
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGraphElementId(graphElementId: string, queryGraph: QueryGraph, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryGraph>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGraphElementId(graphElementId, queryGraph, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete from GraphElement only the class
         * @param {string} graphElementId 
         * @param {string} classIRI The class that should be deleted
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGraphElementIdClass(graphElementId: string, classIRI: string, queryGraph: QueryGraph, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryGraph>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGraphElementIdClass(graphElementId, classIRI, queryGraph, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Starting from only the clicked class get the query graph that will be rendered by Sparqling, the query head, the sparql code. The sparql query returned will be somthing like `select ?x { ?x a <clickedClassIRI>` }. The variable `?x` should be called according to the entity remainder or label. The variable will be added to the head of the query in order to create a valid SPARQL query.
         * @summary This is the first route to call in order to build the query graph.
         * @param {string} clickedClassIRI The IRI of the entity clicked on the GRAPHOLscape ontology graph
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQueryGraph(clickedClassIRI: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryGraph>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQueryGraph(clickedClassIRI, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This call is used when the user click on a highlighted class and should add a triple pattern of the form like `?x rdf:type <targetClassIRI>`. The server should find `?x` in the SPARQL code as the variable associated to the `sourceClassIRI`.
         * @summary Starting from the current query graph continue to build the query graph through a class.
         * @param {string} graphElementId The id of the node of the selected class in the query graph.
         * @param {string} sourceClassIRI The IRI of the last selected class. It could be selected from the ontology graph or from the query graph.
         * @param {string} targetClassIRI The IRI of the entity clicked on the GRAPHOLscape ontology graph.
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putQueryGraphClass(graphElementId: string, sourceClassIRI: string, targetClassIRI: string, queryGraph: QueryGraph, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryGraph>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putQueryGraphClass(graphElementId, sourceClassIRI, targetClassIRI, queryGraph, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This route is used when the user click a highlighted data property. The triple pattern to add is something like `?x <predicateIRI> ?y` where `?x` should be derived from `selectedClassIRI`. Note that `?y` is fresh new variable that should be added also to the head of the query (we assume data property values are interesting). The variable `?y` should be called according to the entity remainder or label and should add a counter if there is an already defined variable for that data property.
         * @summary Starting from the current query graph continue to build the query graph through a data property.
         * @param {string} graphElementId The id of the node of the selected class in the query graph.
         * @param {string} sourceClassIRI The IRI of the last selected class. It could be selected from the ontology graph or from the query graph.
         * @param {string} predicateIRI The IRI of the clicked data property.
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putQueryGraphDataProperty(graphElementId: string, sourceClassIRI: string, predicateIRI: string, queryGraph: QueryGraph, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryGraph>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putQueryGraphDataProperty(graphElementId, sourceClassIRI, predicateIRI, queryGraph, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Starting from a query graph which has two nodes representing the same class(es), it returns the query graph in which the two nodes have been joined into a single one. The children of the selected nodes will be grouped in `graphElementId1` and each time we add a children through the previous routes they will be added to this node.
         * @summary Join two GraphNodeElement in one.
         * @param {string} graphElementId1 The id of the node of the selected class in the query graph.
         * @param {string} graphElementId2 The id of the node of the selected class in the query graph.
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putQueryGraphJoin(graphElementId1: string, graphElementId2: string, queryGraph: QueryGraph, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryGraph>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putQueryGraphJoin(graphElementId1, graphElementId2, queryGraph, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This route is used when the user click a highlighted object property with ornly one `relatedClasses` or, in the case of more than one `relatedClasses` immediatly after choosing one of them. In this case the triple pattern to add is something like `?x <predicateIRI> ?y` where `?x` and `?y` should be derived from the direction indicated by `isPredicateDirect` of the object property with respect to `sourceClassIRI` and `targetClassIRI`. If there is a cyclic object property the user also should specify the direction if order to correctly assign `?x` and `?y`. Either `?x` or `?y` should be a fresh new variable which should be linked to a new triple pattern `?y rdf:type <targetClassIRI>`. The variable `?y` should be called according to the entity remainder or label and should add a counter if there is an already defined variable for that class.
         * @summary Starting from the current query graph continue to build the query graph through a object property.
         * @param {string} graphElementId The id of the node of the selected class in the query graph.
         * @param {string} sourceClassIRI The IRI of the last selected class. It could be selected from the ontology graph or from the query graph.
         * @param {string} predicateIRI The IRI of the predicate which links source class and target class
         * @param {string} targetClassIRI The IRI of the entity clicked on the GRAPHOLscape ontology graph.
         * @param {boolean} isPredicateDirect If true sourceClassIRI is the domain of predicateIRI, if false sourceClassIRI is the range of predicateIRI.
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putQueryGraphObjectProperty(graphElementId: string, sourceClassIRI: string, predicateIRI: string, targetClassIRI: string, isPredicateDirect: boolean, queryGraph: QueryGraph, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryGraph>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putQueryGraphObjectProperty(graphElementId, sourceClassIRI, predicateIRI, targetClassIRI, isPredicateDirect, queryGraph, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * QueryGraphBGPApi - factory interface
 * @export
 */
export const QueryGraphBGPApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QueryGraphBGPApiFp(configuration)
    return {
        /**
         * This path should be used to build the query graph using the path interaction. As a result there will be added to the query several triple pattern (depending on the length of the path) as a sequence of classes and object properties. Data properties never appear in paths, in order to add them use the simple PUT route.
         * @summary Get the query graph that will be rendered by Sparqling, the query head, the sparql code based on the chosen path.
         * @param {string} path Serialization of Path object.
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPathToQueryGraph(path: string, queryGraph: QueryGraph, options?: any): AxiosPromise<QueryGraph> {
            return localVarFp.addPathToQueryGraph(path, queryGraph, options).then((request) => request(axios, basePath));
        },
        /**
         * This route is used when the user wants to delete a node from the query graph. All the children of this node will be deleted as well as we do not want to create query with completly separated branches. All the variables that are going to be deleted should also be deleted from the head of the query. **WARNING**, if the node has multiple occurrences (due to join operations) every node should be deleted.
         * @summary Delete the GraphElement (and all its children) from the query graph and head.
         * @param {string} graphElementId The GraphElement that should be deleted
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGraphElementId(graphElementId: string, queryGraph: QueryGraph, options?: any): AxiosPromise<QueryGraph> {
            return localVarFp.deleteGraphElementId(graphElementId, queryGraph, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete from GraphElement only the class
         * @param {string} graphElementId 
         * @param {string} classIRI The class that should be deleted
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGraphElementIdClass(graphElementId: string, classIRI: string, queryGraph: QueryGraph, options?: any): AxiosPromise<QueryGraph> {
            return localVarFp.deleteGraphElementIdClass(graphElementId, classIRI, queryGraph, options).then((request) => request(axios, basePath));
        },
        /**
         * Starting from only the clicked class get the query graph that will be rendered by Sparqling, the query head, the sparql code. The sparql query returned will be somthing like `select ?x { ?x a <clickedClassIRI>` }. The variable `?x` should be called according to the entity remainder or label. The variable will be added to the head of the query in order to create a valid SPARQL query.
         * @summary This is the first route to call in order to build the query graph.
         * @param {string} clickedClassIRI The IRI of the entity clicked on the GRAPHOLscape ontology graph
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueryGraph(clickedClassIRI: string, options?: any): AxiosPromise<QueryGraph> {
            return localVarFp.getQueryGraph(clickedClassIRI, options).then((request) => request(axios, basePath));
        },
        /**
         * This call is used when the user click on a highlighted class and should add a triple pattern of the form like `?x rdf:type <targetClassIRI>`. The server should find `?x` in the SPARQL code as the variable associated to the `sourceClassIRI`.
         * @summary Starting from the current query graph continue to build the query graph through a class.
         * @param {string} graphElementId The id of the node of the selected class in the query graph.
         * @param {string} sourceClassIRI The IRI of the last selected class. It could be selected from the ontology graph or from the query graph.
         * @param {string} targetClassIRI The IRI of the entity clicked on the GRAPHOLscape ontology graph.
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putQueryGraphClass(graphElementId: string, sourceClassIRI: string, targetClassIRI: string, queryGraph: QueryGraph, options?: any): AxiosPromise<QueryGraph> {
            return localVarFp.putQueryGraphClass(graphElementId, sourceClassIRI, targetClassIRI, queryGraph, options).then((request) => request(axios, basePath));
        },
        /**
         * This route is used when the user click a highlighted data property. The triple pattern to add is something like `?x <predicateIRI> ?y` where `?x` should be derived from `selectedClassIRI`. Note that `?y` is fresh new variable that should be added also to the head of the query (we assume data property values are interesting). The variable `?y` should be called according to the entity remainder or label and should add a counter if there is an already defined variable for that data property.
         * @summary Starting from the current query graph continue to build the query graph through a data property.
         * @param {string} graphElementId The id of the node of the selected class in the query graph.
         * @param {string} sourceClassIRI The IRI of the last selected class. It could be selected from the ontology graph or from the query graph.
         * @param {string} predicateIRI The IRI of the clicked data property.
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putQueryGraphDataProperty(graphElementId: string, sourceClassIRI: string, predicateIRI: string, queryGraph: QueryGraph, options?: any): AxiosPromise<QueryGraph> {
            return localVarFp.putQueryGraphDataProperty(graphElementId, sourceClassIRI, predicateIRI, queryGraph, options).then((request) => request(axios, basePath));
        },
        /**
         * Starting from a query graph which has two nodes representing the same class(es), it returns the query graph in which the two nodes have been joined into a single one. The children of the selected nodes will be grouped in `graphElementId1` and each time we add a children through the previous routes they will be added to this node.
         * @summary Join two GraphNodeElement in one.
         * @param {string} graphElementId1 The id of the node of the selected class in the query graph.
         * @param {string} graphElementId2 The id of the node of the selected class in the query graph.
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putQueryGraphJoin(graphElementId1: string, graphElementId2: string, queryGraph: QueryGraph, options?: any): AxiosPromise<QueryGraph> {
            return localVarFp.putQueryGraphJoin(graphElementId1, graphElementId2, queryGraph, options).then((request) => request(axios, basePath));
        },
        /**
         * This route is used when the user click a highlighted object property with ornly one `relatedClasses` or, in the case of more than one `relatedClasses` immediatly after choosing one of them. In this case the triple pattern to add is something like `?x <predicateIRI> ?y` where `?x` and `?y` should be derived from the direction indicated by `isPredicateDirect` of the object property with respect to `sourceClassIRI` and `targetClassIRI`. If there is a cyclic object property the user also should specify the direction if order to correctly assign `?x` and `?y`. Either `?x` or `?y` should be a fresh new variable which should be linked to a new triple pattern `?y rdf:type <targetClassIRI>`. The variable `?y` should be called according to the entity remainder or label and should add a counter if there is an already defined variable for that class.
         * @summary Starting from the current query graph continue to build the query graph through a object property.
         * @param {string} graphElementId The id of the node of the selected class in the query graph.
         * @param {string} sourceClassIRI The IRI of the last selected class. It could be selected from the ontology graph or from the query graph.
         * @param {string} predicateIRI The IRI of the predicate which links source class and target class
         * @param {string} targetClassIRI The IRI of the entity clicked on the GRAPHOLscape ontology graph.
         * @param {boolean} isPredicateDirect If true sourceClassIRI is the domain of predicateIRI, if false sourceClassIRI is the range of predicateIRI.
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putQueryGraphObjectProperty(graphElementId: string, sourceClassIRI: string, predicateIRI: string, targetClassIRI: string, isPredicateDirect: boolean, queryGraph: QueryGraph, options?: any): AxiosPromise<QueryGraph> {
            return localVarFp.putQueryGraphObjectProperty(graphElementId, sourceClassIRI, predicateIRI, targetClassIRI, isPredicateDirect, queryGraph, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QueryGraphBGPApi - object-oriented interface
 * @export
 * @class QueryGraphBGPApi
 * @extends {BaseAPI}
 */
export class QueryGraphBGPApi extends BaseAPI {
    /**
     * This path should be used to build the query graph using the path interaction. As a result there will be added to the query several triple pattern (depending on the length of the path) as a sequence of classes and object properties. Data properties never appear in paths, in order to add them use the simple PUT route.
     * @summary Get the query graph that will be rendered by Sparqling, the query head, the sparql code based on the chosen path.
     * @param {string} path Serialization of Path object.
     * @param {QueryGraph} queryGraph 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryGraphBGPApi
     */
    public addPathToQueryGraph(path: string, queryGraph: QueryGraph, options?: AxiosRequestConfig) {
        return QueryGraphBGPApiFp(this.configuration).addPathToQueryGraph(path, queryGraph, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This route is used when the user wants to delete a node from the query graph. All the children of this node will be deleted as well as we do not want to create query with completly separated branches. All the variables that are going to be deleted should also be deleted from the head of the query. **WARNING**, if the node has multiple occurrences (due to join operations) every node should be deleted.
     * @summary Delete the GraphElement (and all its children) from the query graph and head.
     * @param {string} graphElementId The GraphElement that should be deleted
     * @param {QueryGraph} queryGraph 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryGraphBGPApi
     */
    public deleteGraphElementId(graphElementId: string, queryGraph: QueryGraph, options?: AxiosRequestConfig) {
        return QueryGraphBGPApiFp(this.configuration).deleteGraphElementId(graphElementId, queryGraph, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete from GraphElement only the class
     * @param {string} graphElementId 
     * @param {string} classIRI The class that should be deleted
     * @param {QueryGraph} queryGraph 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryGraphBGPApi
     */
    public deleteGraphElementIdClass(graphElementId: string, classIRI: string, queryGraph: QueryGraph, options?: AxiosRequestConfig) {
        return QueryGraphBGPApiFp(this.configuration).deleteGraphElementIdClass(graphElementId, classIRI, queryGraph, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Starting from only the clicked class get the query graph that will be rendered by Sparqling, the query head, the sparql code. The sparql query returned will be somthing like `select ?x { ?x a <clickedClassIRI>` }. The variable `?x` should be called according to the entity remainder or label. The variable will be added to the head of the query in order to create a valid SPARQL query.
     * @summary This is the first route to call in order to build the query graph.
     * @param {string} clickedClassIRI The IRI of the entity clicked on the GRAPHOLscape ontology graph
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryGraphBGPApi
     */
    public getQueryGraph(clickedClassIRI: string, options?: AxiosRequestConfig) {
        return QueryGraphBGPApiFp(this.configuration).getQueryGraph(clickedClassIRI, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This call is used when the user click on a highlighted class and should add a triple pattern of the form like `?x rdf:type <targetClassIRI>`. The server should find `?x` in the SPARQL code as the variable associated to the `sourceClassIRI`.
     * @summary Starting from the current query graph continue to build the query graph through a class.
     * @param {string} graphElementId The id of the node of the selected class in the query graph.
     * @param {string} sourceClassIRI The IRI of the last selected class. It could be selected from the ontology graph or from the query graph.
     * @param {string} targetClassIRI The IRI of the entity clicked on the GRAPHOLscape ontology graph.
     * @param {QueryGraph} queryGraph 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryGraphBGPApi
     */
    public putQueryGraphClass(graphElementId: string, sourceClassIRI: string, targetClassIRI: string, queryGraph: QueryGraph, options?: AxiosRequestConfig) {
        return QueryGraphBGPApiFp(this.configuration).putQueryGraphClass(graphElementId, sourceClassIRI, targetClassIRI, queryGraph, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This route is used when the user click a highlighted data property. The triple pattern to add is something like `?x <predicateIRI> ?y` where `?x` should be derived from `selectedClassIRI`. Note that `?y` is fresh new variable that should be added also to the head of the query (we assume data property values are interesting). The variable `?y` should be called according to the entity remainder or label and should add a counter if there is an already defined variable for that data property.
     * @summary Starting from the current query graph continue to build the query graph through a data property.
     * @param {string} graphElementId The id of the node of the selected class in the query graph.
     * @param {string} sourceClassIRI The IRI of the last selected class. It could be selected from the ontology graph or from the query graph.
     * @param {string} predicateIRI The IRI of the clicked data property.
     * @param {QueryGraph} queryGraph 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryGraphBGPApi
     */
    public putQueryGraphDataProperty(graphElementId: string, sourceClassIRI: string, predicateIRI: string, queryGraph: QueryGraph, options?: AxiosRequestConfig) {
        return QueryGraphBGPApiFp(this.configuration).putQueryGraphDataProperty(graphElementId, sourceClassIRI, predicateIRI, queryGraph, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Starting from a query graph which has two nodes representing the same class(es), it returns the query graph in which the two nodes have been joined into a single one. The children of the selected nodes will be grouped in `graphElementId1` and each time we add a children through the previous routes they will be added to this node.
     * @summary Join two GraphNodeElement in one.
     * @param {string} graphElementId1 The id of the node of the selected class in the query graph.
     * @param {string} graphElementId2 The id of the node of the selected class in the query graph.
     * @param {QueryGraph} queryGraph 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryGraphBGPApi
     */
    public putQueryGraphJoin(graphElementId1: string, graphElementId2: string, queryGraph: QueryGraph, options?: AxiosRequestConfig) {
        return QueryGraphBGPApiFp(this.configuration).putQueryGraphJoin(graphElementId1, graphElementId2, queryGraph, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This route is used when the user click a highlighted object property with ornly one `relatedClasses` or, in the case of more than one `relatedClasses` immediatly after choosing one of them. In this case the triple pattern to add is something like `?x <predicateIRI> ?y` where `?x` and `?y` should be derived from the direction indicated by `isPredicateDirect` of the object property with respect to `sourceClassIRI` and `targetClassIRI`. If there is a cyclic object property the user also should specify the direction if order to correctly assign `?x` and `?y`. Either `?x` or `?y` should be a fresh new variable which should be linked to a new triple pattern `?y rdf:type <targetClassIRI>`. The variable `?y` should be called according to the entity remainder or label and should add a counter if there is an already defined variable for that class.
     * @summary Starting from the current query graph continue to build the query graph through a object property.
     * @param {string} graphElementId The id of the node of the selected class in the query graph.
     * @param {string} sourceClassIRI The IRI of the last selected class. It could be selected from the ontology graph or from the query graph.
     * @param {string} predicateIRI The IRI of the predicate which links source class and target class
     * @param {string} targetClassIRI The IRI of the entity clicked on the GRAPHOLscape ontology graph.
     * @param {boolean} isPredicateDirect If true sourceClassIRI is the domain of predicateIRI, if false sourceClassIRI is the range of predicateIRI.
     * @param {QueryGraph} queryGraph 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryGraphBGPApi
     */
    public putQueryGraphObjectProperty(graphElementId: string, sourceClassIRI: string, predicateIRI: string, targetClassIRI: string, isPredicateDirect: boolean, queryGraph: QueryGraph, options?: AxiosRequestConfig) {
        return QueryGraphBGPApiFp(this.configuration).putQueryGraphObjectProperty(graphElementId, sourceClassIRI, predicateIRI, targetClassIRI, isPredicateDirect, queryGraph, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * QueryGraphExtraApi - axios parameter creator
 * @export
 */
export const QueryGraphExtraApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove query head and replace it with `count(*)`.
         * @param {boolean} distinct 
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countStarQueryGraph: async (distinct: boolean, queryGraph: QueryGraph, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'distinct' is not null or undefined
            assertParamExists('countStarQueryGraph', 'distinct', distinct)
            // verify required parameter 'queryGraph' is not null or undefined
            assertParamExists('countStarQueryGraph', 'queryGraph', queryGraph)
            const localVarPath = `/queryGraph/countStar`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (distinct !== undefined) {
                localVarQueryParameter['distinct'] = distinct;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(queryGraph, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The distinct value is defined in the query graph in the request body.
         * @summary Set the distinct value.
         * @param {boolean} distinct 
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distinctQueryGraph: async (distinct: boolean, queryGraph: QueryGraph, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'distinct' is not null or undefined
            assertParamExists('distinctQueryGraph', 'distinct', distinct)
            // verify required parameter 'queryGraph' is not null or undefined
            assertParamExists('distinctQueryGraph', 'queryGraph', queryGraph)
            const localVarPath = `/queryGraph/distinct`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (distinct !== undefined) {
                localVarQueryParameter['distinct'] = distinct;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(queryGraph, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The limit value is defined in the query graph in the request body.
         * @summary Set the limit value.
         * @param {number} limit 
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        limitQueryGraph: async (limit: number, queryGraph: QueryGraph, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('limitQueryGraph', 'limit', limit)
            // verify required parameter 'queryGraph' is not null or undefined
            assertParamExists('limitQueryGraph', 'queryGraph', queryGraph)
            const localVarPath = `/queryGraph/limit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(queryGraph, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The offset value is defined in the query graph in the request body.
         * @summary Set the offset value.
         * @param {number} offset 
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        offsetQueryGraph: async (offset: number, queryGraph: QueryGraph, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'offset' is not null or undefined
            assertParamExists('offsetQueryGraph', 'offset', offset)
            // verify required parameter 'queryGraph' is not null or undefined
            assertParamExists('offsetQueryGraph', 'queryGraph', queryGraph)
            const localVarPath = `/queryGraph/offset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(queryGraph, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QueryGraphExtraApi - functional programming interface
 * @export
 */
export const QueryGraphExtraApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QueryGraphExtraApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove query head and replace it with `count(*)`.
         * @param {boolean} distinct 
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countStarQueryGraph(distinct: boolean, queryGraph: QueryGraph, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryGraph>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countStarQueryGraph(distinct, queryGraph, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The distinct value is defined in the query graph in the request body.
         * @summary Set the distinct value.
         * @param {boolean} distinct 
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async distinctQueryGraph(distinct: boolean, queryGraph: QueryGraph, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryGraph>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.distinctQueryGraph(distinct, queryGraph, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The limit value is defined in the query graph in the request body.
         * @summary Set the limit value.
         * @param {number} limit 
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async limitQueryGraph(limit: number, queryGraph: QueryGraph, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryGraph>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.limitQueryGraph(limit, queryGraph, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The offset value is defined in the query graph in the request body.
         * @summary Set the offset value.
         * @param {number} offset 
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async offsetQueryGraph(offset: number, queryGraph: QueryGraph, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryGraph>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.offsetQueryGraph(offset, queryGraph, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * QueryGraphExtraApi - factory interface
 * @export
 */
export const QueryGraphExtraApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QueryGraphExtraApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove query head and replace it with `count(*)`.
         * @param {boolean} distinct 
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countStarQueryGraph(distinct: boolean, queryGraph: QueryGraph, options?: any): AxiosPromise<QueryGraph> {
            return localVarFp.countStarQueryGraph(distinct, queryGraph, options).then((request) => request(axios, basePath));
        },
        /**
         * The distinct value is defined in the query graph in the request body.
         * @summary Set the distinct value.
         * @param {boolean} distinct 
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        distinctQueryGraph(distinct: boolean, queryGraph: QueryGraph, options?: any): AxiosPromise<QueryGraph> {
            return localVarFp.distinctQueryGraph(distinct, queryGraph, options).then((request) => request(axios, basePath));
        },
        /**
         * The limit value is defined in the query graph in the request body.
         * @summary Set the limit value.
         * @param {number} limit 
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        limitQueryGraph(limit: number, queryGraph: QueryGraph, options?: any): AxiosPromise<QueryGraph> {
            return localVarFp.limitQueryGraph(limit, queryGraph, options).then((request) => request(axios, basePath));
        },
        /**
         * The offset value is defined in the query graph in the request body.
         * @summary Set the offset value.
         * @param {number} offset 
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        offsetQueryGraph(offset: number, queryGraph: QueryGraph, options?: any): AxiosPromise<QueryGraph> {
            return localVarFp.offsetQueryGraph(offset, queryGraph, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QueryGraphExtraApi - object-oriented interface
 * @export
 * @class QueryGraphExtraApi
 * @extends {BaseAPI}
 */
export class QueryGraphExtraApi extends BaseAPI {
    /**
     * 
     * @summary Remove query head and replace it with `count(*)`.
     * @param {boolean} distinct 
     * @param {QueryGraph} queryGraph 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryGraphExtraApi
     */
    public countStarQueryGraph(distinct: boolean, queryGraph: QueryGraph, options?: AxiosRequestConfig) {
        return QueryGraphExtraApiFp(this.configuration).countStarQueryGraph(distinct, queryGraph, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The distinct value is defined in the query graph in the request body.
     * @summary Set the distinct value.
     * @param {boolean} distinct 
     * @param {QueryGraph} queryGraph 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryGraphExtraApi
     */
    public distinctQueryGraph(distinct: boolean, queryGraph: QueryGraph, options?: AxiosRequestConfig) {
        return QueryGraphExtraApiFp(this.configuration).distinctQueryGraph(distinct, queryGraph, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The limit value is defined in the query graph in the request body.
     * @summary Set the limit value.
     * @param {number} limit 
     * @param {QueryGraph} queryGraph 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryGraphExtraApi
     */
    public limitQueryGraph(limit: number, queryGraph: QueryGraph, options?: AxiosRequestConfig) {
        return QueryGraphExtraApiFp(this.configuration).limitQueryGraph(limit, queryGraph, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The offset value is defined in the query graph in the request body.
     * @summary Set the offset value.
     * @param {number} offset 
     * @param {QueryGraph} queryGraph 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryGraphExtraApi
     */
    public offsetQueryGraph(offset: number, queryGraph: QueryGraph, options?: AxiosRequestConfig) {
        return QueryGraphExtraApiFp(this.configuration).offsetQueryGraph(offset, queryGraph, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * QueryGraphFilterApi - axios parameter creator
 * @export
 */
export const QueryGraphFilterApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Translate the filter at index `filterId` to a filter in SPARQL.
         * @summary Modify a filter in the query.
         * @param {number} filterId 
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editFilter: async (filterId: number, queryGraph: QueryGraph, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filterId' is not null or undefined
            assertParamExists('editFilter', 'filterId', filterId)
            // verify required parameter 'queryGraph' is not null or undefined
            assertParamExists('editFilter', 'queryGraph', queryGraph)
            const localVarPath = `/queryGraph/node/filter/edit/{filterId}`
                .replace(`{${"filterId"}}`, encodeURIComponent(String(filterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(queryGraph, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Translate the filter at index `filterId` to a new filter in SPARQL.
         * @summary Create a new filter in the query.
         * @param {number} filterId 
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newFilter: async (filterId: number, queryGraph: QueryGraph, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filterId' is not null or undefined
            assertParamExists('newFilter', 'filterId', filterId)
            // verify required parameter 'queryGraph' is not null or undefined
            assertParamExists('newFilter', 'queryGraph', queryGraph)
            const localVarPath = `/queryGraph/node/filter/{filterId}`
                .replace(`{${"filterId"}}`, encodeURIComponent(String(filterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(queryGraph, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the filters.
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAllFilters: async (queryGraph: QueryGraph, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'queryGraph' is not null or undefined
            assertParamExists('removeAllFilters', 'queryGraph', queryGraph)
            const localVarPath = `/queryGraph/node/filter/remove/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(queryGraph, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the filter at index `filterId` from the query.
         * @param {number} filterId 
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeFilter: async (filterId: number, queryGraph: QueryGraph, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filterId' is not null or undefined
            assertParamExists('removeFilter', 'filterId', filterId)
            // verify required parameter 'queryGraph' is not null or undefined
            assertParamExists('removeFilter', 'queryGraph', queryGraph)
            const localVarPath = `/queryGraph/node/filter/remove/{filterId}`
                .replace(`{${"filterId"}}`, encodeURIComponent(String(filterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(queryGraph, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QueryGraphFilterApi - functional programming interface
 * @export
 */
export const QueryGraphFilterApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QueryGraphFilterApiAxiosParamCreator(configuration)
    return {
        /**
         * Translate the filter at index `filterId` to a filter in SPARQL.
         * @summary Modify a filter in the query.
         * @param {number} filterId 
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editFilter(filterId: number, queryGraph: QueryGraph, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryGraph>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editFilter(filterId, queryGraph, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Translate the filter at index `filterId` to a new filter in SPARQL.
         * @summary Create a new filter in the query.
         * @param {number} filterId 
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async newFilter(filterId: number, queryGraph: QueryGraph, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryGraph>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.newFilter(filterId, queryGraph, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove the filters.
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeAllFilters(queryGraph: QueryGraph, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryGraph>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeAllFilters(queryGraph, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove the filter at index `filterId` from the query.
         * @param {number} filterId 
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeFilter(filterId: number, queryGraph: QueryGraph, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryGraph>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeFilter(filterId, queryGraph, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * QueryGraphFilterApi - factory interface
 * @export
 */
export const QueryGraphFilterApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QueryGraphFilterApiFp(configuration)
    return {
        /**
         * Translate the filter at index `filterId` to a filter in SPARQL.
         * @summary Modify a filter in the query.
         * @param {number} filterId 
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editFilter(filterId: number, queryGraph: QueryGraph, options?: any): AxiosPromise<QueryGraph> {
            return localVarFp.editFilter(filterId, queryGraph, options).then((request) => request(axios, basePath));
        },
        /**
         * Translate the filter at index `filterId` to a new filter in SPARQL.
         * @summary Create a new filter in the query.
         * @param {number} filterId 
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newFilter(filterId: number, queryGraph: QueryGraph, options?: any): AxiosPromise<QueryGraph> {
            return localVarFp.newFilter(filterId, queryGraph, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the filters.
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAllFilters(queryGraph: QueryGraph, options?: any): AxiosPromise<QueryGraph> {
            return localVarFp.removeAllFilters(queryGraph, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the filter at index `filterId` from the query.
         * @param {number} filterId 
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeFilter(filterId: number, queryGraph: QueryGraph, options?: any): AxiosPromise<QueryGraph> {
            return localVarFp.removeFilter(filterId, queryGraph, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QueryGraphFilterApi - object-oriented interface
 * @export
 * @class QueryGraphFilterApi
 * @extends {BaseAPI}
 */
export class QueryGraphFilterApi extends BaseAPI {
    /**
     * Translate the filter at index `filterId` to a filter in SPARQL.
     * @summary Modify a filter in the query.
     * @param {number} filterId 
     * @param {QueryGraph} queryGraph 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryGraphFilterApi
     */
    public editFilter(filterId: number, queryGraph: QueryGraph, options?: AxiosRequestConfig) {
        return QueryGraphFilterApiFp(this.configuration).editFilter(filterId, queryGraph, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Translate the filter at index `filterId` to a new filter in SPARQL.
     * @summary Create a new filter in the query.
     * @param {number} filterId 
     * @param {QueryGraph} queryGraph 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryGraphFilterApi
     */
    public newFilter(filterId: number, queryGraph: QueryGraph, options?: AxiosRequestConfig) {
        return QueryGraphFilterApiFp(this.configuration).newFilter(filterId, queryGraph, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the filters.
     * @param {QueryGraph} queryGraph 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryGraphFilterApi
     */
    public removeAllFilters(queryGraph: QueryGraph, options?: AxiosRequestConfig) {
        return QueryGraphFilterApiFp(this.configuration).removeAllFilters(queryGraph, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the filter at index `filterId` from the query.
     * @param {number} filterId 
     * @param {QueryGraph} queryGraph 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryGraphFilterApi
     */
    public removeFilter(filterId: number, queryGraph: QueryGraph, options?: AxiosRequestConfig) {
        return QueryGraphFilterApiFp(this.configuration).removeFilter(filterId, queryGraph, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * QueryGraphHeadApi - axios parameter creator
 * @export
 */
export const QueryGraphHeadApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Explicitley add a term to the query head. All the data property variables are added automatically to the head during the query graph construction. This will add to the head only variables associated to classes (`rdf:type` triple pattern) or data properties.
         * @summary Add the head term to the query graph.
         * @param {string} graphElementId The id of the graph node that should be added to the head
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addHeadTerm: async (graphElementId: string, queryGraph: QueryGraph, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'graphElementId' is not null or undefined
            assertParamExists('addHeadTerm', 'graphElementId', graphElementId)
            // verify required parameter 'queryGraph' is not null or undefined
            assertParamExists('addHeadTerm', 'queryGraph', queryGraph)
            const localVarPath = `/queryGraph/head/add/{graphElementId}`
                .replace(`{${"graphElementId"}}`, encodeURIComponent(String(graphElementId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(queryGraph, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The aggregation function is defined in the group by field of the query graph in the request body along with the HAVING clause. Remember to set the alias of the head based on function name and variable.
         * @summary Set the aggregation function to the head term.
         * @param {string} headTerm The head term that should be involved in the aggregation function
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aggregationHeadTerm: async (headTerm: string, queryGraph: QueryGraph, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'headTerm' is not null or undefined
            assertParamExists('aggregationHeadTerm', 'headTerm', headTerm)
            // verify required parameter 'queryGraph' is not null or undefined
            assertParamExists('aggregationHeadTerm', 'queryGraph', queryGraph)
            const localVarPath = `/queryGraph/head/aggregation/{headTerm}`
                .replace(`{${"headTerm"}}`, encodeURIComponent(String(headTerm)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(queryGraph, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The path param should be the id of the HeadElement.
         * @summary Delete the head term from the query graph.
         * @param {string} headTerm The head term that should be deleted
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHeadTerm: async (headTerm: string, queryGraph: QueryGraph, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'headTerm' is not null or undefined
            assertParamExists('deleteHeadTerm', 'headTerm', headTerm)
            // verify required parameter 'queryGraph' is not null or undefined
            assertParamExists('deleteHeadTerm', 'queryGraph', queryGraph)
            const localVarPath = `/queryGraph/head/delete/{headTerm}`
                .replace(`{${"headTerm"}}`, encodeURIComponent(String(headTerm)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(queryGraph, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The function is defined in the head term of the query graph in the request body. Remember to set the alias of the head based on function name and variable.
         * @summary Set a function to the head term from the query graph.
         * @param {string} headTerm The head term that should be involved inthe function
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        functionHeadTerm: async (headTerm: string, queryGraph: QueryGraph, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'headTerm' is not null or undefined
            assertParamExists('functionHeadTerm', 'headTerm', headTerm)
            // verify required parameter 'queryGraph' is not null or undefined
            assertParamExists('functionHeadTerm', 'queryGraph', queryGraph)
            const localVarPath = `/queryGraph/head/function/{headTerm}`
                .replace(`{${"headTerm"}}`, encodeURIComponent(String(headTerm)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(queryGraph, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The OrderBy object is passed in the request body in the Query Graph.
         * @summary Order by the head from the query graph.
         * @param {string} headTerm The head term that should be ordered
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderByHeadTerm: async (headTerm: string, queryGraph: QueryGraph, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'headTerm' is not null or undefined
            assertParamExists('orderByHeadTerm', 'headTerm', headTerm)
            // verify required parameter 'queryGraph' is not null or undefined
            assertParamExists('orderByHeadTerm', 'queryGraph', queryGraph)
            const localVarPath = `/queryGraph/head/orderBy/{headTerm}`
                .replace(`{${"headTerm"}}`, encodeURIComponent(String(headTerm)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(queryGraph, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Put the alias in the HeadElement passed via request body.
         * @summary Rename the head term from the query graph using alias.
         * @param {string} headTerm The head term that should be renamed
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameHeadTerm: async (headTerm: string, queryGraph: QueryGraph, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'headTerm' is not null or undefined
            assertParamExists('renameHeadTerm', 'headTerm', headTerm)
            // verify required parameter 'queryGraph' is not null or undefined
            assertParamExists('renameHeadTerm', 'queryGraph', queryGraph)
            const localVarPath = `/queryGraph/head/rename/{headTerm}`
                .replace(`{${"headTerm"}}`, encodeURIComponent(String(headTerm)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(queryGraph, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reorder the head elements accrding to Query GRaph object.
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reorderHeadTerms: async (queryGraph: QueryGraph, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'queryGraph' is not null or undefined
            assertParamExists('reorderHeadTerms', 'queryGraph', queryGraph)
            const localVarPath = `/queryGraph/head/reorderHeadTerms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(queryGraph, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QueryGraphHeadApi - functional programming interface
 * @export
 */
export const QueryGraphHeadApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QueryGraphHeadApiAxiosParamCreator(configuration)
    return {
        /**
         * Explicitley add a term to the query head. All the data property variables are added automatically to the head during the query graph construction. This will add to the head only variables associated to classes (`rdf:type` triple pattern) or data properties.
         * @summary Add the head term to the query graph.
         * @param {string} graphElementId The id of the graph node that should be added to the head
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addHeadTerm(graphElementId: string, queryGraph: QueryGraph, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryGraph>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addHeadTerm(graphElementId, queryGraph, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The aggregation function is defined in the group by field of the query graph in the request body along with the HAVING clause. Remember to set the alias of the head based on function name and variable.
         * @summary Set the aggregation function to the head term.
         * @param {string} headTerm The head term that should be involved in the aggregation function
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aggregationHeadTerm(headTerm: string, queryGraph: QueryGraph, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryGraph>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aggregationHeadTerm(headTerm, queryGraph, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The path param should be the id of the HeadElement.
         * @summary Delete the head term from the query graph.
         * @param {string} headTerm The head term that should be deleted
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteHeadTerm(headTerm: string, queryGraph: QueryGraph, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryGraph>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteHeadTerm(headTerm, queryGraph, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The function is defined in the head term of the query graph in the request body. Remember to set the alias of the head based on function name and variable.
         * @summary Set a function to the head term from the query graph.
         * @param {string} headTerm The head term that should be involved inthe function
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async functionHeadTerm(headTerm: string, queryGraph: QueryGraph, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryGraph>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.functionHeadTerm(headTerm, queryGraph, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The OrderBy object is passed in the request body in the Query Graph.
         * @summary Order by the head from the query graph.
         * @param {string} headTerm The head term that should be ordered
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderByHeadTerm(headTerm: string, queryGraph: QueryGraph, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryGraph>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderByHeadTerm(headTerm, queryGraph, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Put the alias in the HeadElement passed via request body.
         * @summary Rename the head term from the query graph using alias.
         * @param {string} headTerm The head term that should be renamed
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async renameHeadTerm(headTerm: string, queryGraph: QueryGraph, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryGraph>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.renameHeadTerm(headTerm, queryGraph, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Reorder the head elements accrding to Query GRaph object.
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reorderHeadTerms(queryGraph: QueryGraph, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryGraph>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reorderHeadTerms(queryGraph, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * QueryGraphHeadApi - factory interface
 * @export
 */
export const QueryGraphHeadApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QueryGraphHeadApiFp(configuration)
    return {
        /**
         * Explicitley add a term to the query head. All the data property variables are added automatically to the head during the query graph construction. This will add to the head only variables associated to classes (`rdf:type` triple pattern) or data properties.
         * @summary Add the head term to the query graph.
         * @param {string} graphElementId The id of the graph node that should be added to the head
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addHeadTerm(graphElementId: string, queryGraph: QueryGraph, options?: any): AxiosPromise<QueryGraph> {
            return localVarFp.addHeadTerm(graphElementId, queryGraph, options).then((request) => request(axios, basePath));
        },
        /**
         * The aggregation function is defined in the group by field of the query graph in the request body along with the HAVING clause. Remember to set the alias of the head based on function name and variable.
         * @summary Set the aggregation function to the head term.
         * @param {string} headTerm The head term that should be involved in the aggregation function
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aggregationHeadTerm(headTerm: string, queryGraph: QueryGraph, options?: any): AxiosPromise<QueryGraph> {
            return localVarFp.aggregationHeadTerm(headTerm, queryGraph, options).then((request) => request(axios, basePath));
        },
        /**
         * The path param should be the id of the HeadElement.
         * @summary Delete the head term from the query graph.
         * @param {string} headTerm The head term that should be deleted
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHeadTerm(headTerm: string, queryGraph: QueryGraph, options?: any): AxiosPromise<QueryGraph> {
            return localVarFp.deleteHeadTerm(headTerm, queryGraph, options).then((request) => request(axios, basePath));
        },
        /**
         * The function is defined in the head term of the query graph in the request body. Remember to set the alias of the head based on function name and variable.
         * @summary Set a function to the head term from the query graph.
         * @param {string} headTerm The head term that should be involved inthe function
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        functionHeadTerm(headTerm: string, queryGraph: QueryGraph, options?: any): AxiosPromise<QueryGraph> {
            return localVarFp.functionHeadTerm(headTerm, queryGraph, options).then((request) => request(axios, basePath));
        },
        /**
         * The OrderBy object is passed in the request body in the Query Graph.
         * @summary Order by the head from the query graph.
         * @param {string} headTerm The head term that should be ordered
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderByHeadTerm(headTerm: string, queryGraph: QueryGraph, options?: any): AxiosPromise<QueryGraph> {
            return localVarFp.orderByHeadTerm(headTerm, queryGraph, options).then((request) => request(axios, basePath));
        },
        /**
         * Put the alias in the HeadElement passed via request body.
         * @summary Rename the head term from the query graph using alias.
         * @param {string} headTerm The head term that should be renamed
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameHeadTerm(headTerm: string, queryGraph: QueryGraph, options?: any): AxiosPromise<QueryGraph> {
            return localVarFp.renameHeadTerm(headTerm, queryGraph, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reorder the head elements accrding to Query GRaph object.
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reorderHeadTerms(queryGraph: QueryGraph, options?: any): AxiosPromise<QueryGraph> {
            return localVarFp.reorderHeadTerms(queryGraph, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QueryGraphHeadApi - object-oriented interface
 * @export
 * @class QueryGraphHeadApi
 * @extends {BaseAPI}
 */
export class QueryGraphHeadApi extends BaseAPI {
    /**
     * Explicitley add a term to the query head. All the data property variables are added automatically to the head during the query graph construction. This will add to the head only variables associated to classes (`rdf:type` triple pattern) or data properties.
     * @summary Add the head term to the query graph.
     * @param {string} graphElementId The id of the graph node that should be added to the head
     * @param {QueryGraph} queryGraph 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryGraphHeadApi
     */
    public addHeadTerm(graphElementId: string, queryGraph: QueryGraph, options?: AxiosRequestConfig) {
        return QueryGraphHeadApiFp(this.configuration).addHeadTerm(graphElementId, queryGraph, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The aggregation function is defined in the group by field of the query graph in the request body along with the HAVING clause. Remember to set the alias of the head based on function name and variable.
     * @summary Set the aggregation function to the head term.
     * @param {string} headTerm The head term that should be involved in the aggregation function
     * @param {QueryGraph} queryGraph 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryGraphHeadApi
     */
    public aggregationHeadTerm(headTerm: string, queryGraph: QueryGraph, options?: AxiosRequestConfig) {
        return QueryGraphHeadApiFp(this.configuration).aggregationHeadTerm(headTerm, queryGraph, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The path param should be the id of the HeadElement.
     * @summary Delete the head term from the query graph.
     * @param {string} headTerm The head term that should be deleted
     * @param {QueryGraph} queryGraph 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryGraphHeadApi
     */
    public deleteHeadTerm(headTerm: string, queryGraph: QueryGraph, options?: AxiosRequestConfig) {
        return QueryGraphHeadApiFp(this.configuration).deleteHeadTerm(headTerm, queryGraph, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The function is defined in the head term of the query graph in the request body. Remember to set the alias of the head based on function name and variable.
     * @summary Set a function to the head term from the query graph.
     * @param {string} headTerm The head term that should be involved inthe function
     * @param {QueryGraph} queryGraph 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryGraphHeadApi
     */
    public functionHeadTerm(headTerm: string, queryGraph: QueryGraph, options?: AxiosRequestConfig) {
        return QueryGraphHeadApiFp(this.configuration).functionHeadTerm(headTerm, queryGraph, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The OrderBy object is passed in the request body in the Query Graph.
     * @summary Order by the head from the query graph.
     * @param {string} headTerm The head term that should be ordered
     * @param {QueryGraph} queryGraph 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryGraphHeadApi
     */
    public orderByHeadTerm(headTerm: string, queryGraph: QueryGraph, options?: AxiosRequestConfig) {
        return QueryGraphHeadApiFp(this.configuration).orderByHeadTerm(headTerm, queryGraph, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Put the alias in the HeadElement passed via request body.
     * @summary Rename the head term from the query graph using alias.
     * @param {string} headTerm The head term that should be renamed
     * @param {QueryGraph} queryGraph 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryGraphHeadApi
     */
    public renameHeadTerm(headTerm: string, queryGraph: QueryGraph, options?: AxiosRequestConfig) {
        return QueryGraphHeadApiFp(this.configuration).renameHeadTerm(headTerm, queryGraph, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reorder the head elements accrding to Query GRaph object.
     * @param {QueryGraph} queryGraph 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryGraphHeadApi
     */
    public reorderHeadTerms(queryGraph: QueryGraph, options?: AxiosRequestConfig) {
        return QueryGraphHeadApiFp(this.configuration).reorderHeadTerms(queryGraph, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * QueryGraphOptionalApi - axios parameter creator
 * @export
 */
export const QueryGraphOptionalApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new optional in the query and add the triple pattern(s) identified by the GraphElementId. - If it is a class the query parameter should be used and the triple pattern `?graphElementId rdf:type <classIRI>` will be moved from the bgp to the new optional. - If it is a data property the tp `?graphElementIdVar1 <graphElementIdDataPropertyIRI> ?graphElementIdVar2` will be added to the new optional. - If it is a object property the tps `?graphElementIdVar1 <graphElementIdDataPropertyIRI> ?graphElementIdVar2. ?graphElementIdVar2 rdf:type <classIRI>` till the leaves will be moved to the new optional.
         * @summary Add the `graphElementId` to a new optional.
         * @param {string} graphElementId The GraphElement that should be added to the optional
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newOptionalGraphElementId: async (graphElementId: string, queryGraph: QueryGraph, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'graphElementId' is not null or undefined
            assertParamExists('newOptionalGraphElementId', 'graphElementId', graphElementId)
            // verify required parameter 'queryGraph' is not null or undefined
            assertParamExists('newOptionalGraphElementId', 'queryGraph', queryGraph)
            const localVarPath = `/queryGraph/node/optional/{graphElementId}`
                .replace(`{${"graphElementId"}}`, encodeURIComponent(String(graphElementId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(queryGraph, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the optionals and move them back to the bgp.
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAllOptional: async (queryGraph: QueryGraph, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'queryGraph' is not null or undefined
            assertParamExists('removeAllOptional', 'queryGraph', queryGraph)
            const localVarPath = `/queryGraph/node/optional/remove/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(queryGraph, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove the triple pattern(s) identified by the `graphElementId` from all the optional that contains the graphElementId. - If it is a class the query parameter should be used and the triple pattern `?graphElementId rdf:type <classIRI>` will be moved from the optional to the bgp. - If it is a data property the tp `?graphElementIdVar1 <graphElementIdDataPropertyIRI> ?graphElementIdVar2` will be moved from the optional to the bgp. - If it is a object property the tps `?graphElementIdVar1 <graphElementIdDataPropertyIRI> ?graphElementIdVar2. ?graphElementIdVar2 rdf:type <classIRI>` will be moved from the optional to the bgp.
         * @summary Remove the graphElementId from the optional and move it back to the bgp.
         * @param {string} graphElementId The GraphElement that should be removed from the optional
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeOptionalGraphElementId: async (graphElementId: string, queryGraph: QueryGraph, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'graphElementId' is not null or undefined
            assertParamExists('removeOptionalGraphElementId', 'graphElementId', graphElementId)
            // verify required parameter 'queryGraph' is not null or undefined
            assertParamExists('removeOptionalGraphElementId', 'queryGraph', queryGraph)
            const localVarPath = `/queryGraph/node/optional/remove/{graphElementId}`
                .replace(`{${"graphElementId"}}`, encodeURIComponent(String(graphElementId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(queryGraph, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QueryGraphOptionalApi - functional programming interface
 * @export
 */
export const QueryGraphOptionalApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QueryGraphOptionalApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new optional in the query and add the triple pattern(s) identified by the GraphElementId. - If it is a class the query parameter should be used and the triple pattern `?graphElementId rdf:type <classIRI>` will be moved from the bgp to the new optional. - If it is a data property the tp `?graphElementIdVar1 <graphElementIdDataPropertyIRI> ?graphElementIdVar2` will be added to the new optional. - If it is a object property the tps `?graphElementIdVar1 <graphElementIdDataPropertyIRI> ?graphElementIdVar2. ?graphElementIdVar2 rdf:type <classIRI>` till the leaves will be moved to the new optional.
         * @summary Add the `graphElementId` to a new optional.
         * @param {string} graphElementId The GraphElement that should be added to the optional
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async newOptionalGraphElementId(graphElementId: string, queryGraph: QueryGraph, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryGraph>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.newOptionalGraphElementId(graphElementId, queryGraph, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove the optionals and move them back to the bgp.
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeAllOptional(queryGraph: QueryGraph, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryGraph>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeAllOptional(queryGraph, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove the triple pattern(s) identified by the `graphElementId` from all the optional that contains the graphElementId. - If it is a class the query parameter should be used and the triple pattern `?graphElementId rdf:type <classIRI>` will be moved from the optional to the bgp. - If it is a data property the tp `?graphElementIdVar1 <graphElementIdDataPropertyIRI> ?graphElementIdVar2` will be moved from the optional to the bgp. - If it is a object property the tps `?graphElementIdVar1 <graphElementIdDataPropertyIRI> ?graphElementIdVar2. ?graphElementIdVar2 rdf:type <classIRI>` will be moved from the optional to the bgp.
         * @summary Remove the graphElementId from the optional and move it back to the bgp.
         * @param {string} graphElementId The GraphElement that should be removed from the optional
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeOptionalGraphElementId(graphElementId: string, queryGraph: QueryGraph, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryGraph>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeOptionalGraphElementId(graphElementId, queryGraph, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * QueryGraphOptionalApi - factory interface
 * @export
 */
export const QueryGraphOptionalApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QueryGraphOptionalApiFp(configuration)
    return {
        /**
         * Create a new optional in the query and add the triple pattern(s) identified by the GraphElementId. - If it is a class the query parameter should be used and the triple pattern `?graphElementId rdf:type <classIRI>` will be moved from the bgp to the new optional. - If it is a data property the tp `?graphElementIdVar1 <graphElementIdDataPropertyIRI> ?graphElementIdVar2` will be added to the new optional. - If it is a object property the tps `?graphElementIdVar1 <graphElementIdDataPropertyIRI> ?graphElementIdVar2. ?graphElementIdVar2 rdf:type <classIRI>` till the leaves will be moved to the new optional.
         * @summary Add the `graphElementId` to a new optional.
         * @param {string} graphElementId The GraphElement that should be added to the optional
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newOptionalGraphElementId(graphElementId: string, queryGraph: QueryGraph, options?: any): AxiosPromise<QueryGraph> {
            return localVarFp.newOptionalGraphElementId(graphElementId, queryGraph, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the optionals and move them back to the bgp.
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAllOptional(queryGraph: QueryGraph, options?: any): AxiosPromise<QueryGraph> {
            return localVarFp.removeAllOptional(queryGraph, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove the triple pattern(s) identified by the `graphElementId` from all the optional that contains the graphElementId. - If it is a class the query parameter should be used and the triple pattern `?graphElementId rdf:type <classIRI>` will be moved from the optional to the bgp. - If it is a data property the tp `?graphElementIdVar1 <graphElementIdDataPropertyIRI> ?graphElementIdVar2` will be moved from the optional to the bgp. - If it is a object property the tps `?graphElementIdVar1 <graphElementIdDataPropertyIRI> ?graphElementIdVar2. ?graphElementIdVar2 rdf:type <classIRI>` will be moved from the optional to the bgp.
         * @summary Remove the graphElementId from the optional and move it back to the bgp.
         * @param {string} graphElementId The GraphElement that should be removed from the optional
         * @param {QueryGraph} queryGraph 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeOptionalGraphElementId(graphElementId: string, queryGraph: QueryGraph, options?: any): AxiosPromise<QueryGraph> {
            return localVarFp.removeOptionalGraphElementId(graphElementId, queryGraph, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QueryGraphOptionalApi - object-oriented interface
 * @export
 * @class QueryGraphOptionalApi
 * @extends {BaseAPI}
 */
export class QueryGraphOptionalApi extends BaseAPI {
    /**
     * Create a new optional in the query and add the triple pattern(s) identified by the GraphElementId. - If it is a class the query parameter should be used and the triple pattern `?graphElementId rdf:type <classIRI>` will be moved from the bgp to the new optional. - If it is a data property the tp `?graphElementIdVar1 <graphElementIdDataPropertyIRI> ?graphElementIdVar2` will be added to the new optional. - If it is a object property the tps `?graphElementIdVar1 <graphElementIdDataPropertyIRI> ?graphElementIdVar2. ?graphElementIdVar2 rdf:type <classIRI>` till the leaves will be moved to the new optional.
     * @summary Add the `graphElementId` to a new optional.
     * @param {string} graphElementId The GraphElement that should be added to the optional
     * @param {QueryGraph} queryGraph 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryGraphOptionalApi
     */
    public newOptionalGraphElementId(graphElementId: string, queryGraph: QueryGraph, options?: AxiosRequestConfig) {
        return QueryGraphOptionalApiFp(this.configuration).newOptionalGraphElementId(graphElementId, queryGraph, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the optionals and move them back to the bgp.
     * @param {QueryGraph} queryGraph 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryGraphOptionalApi
     */
    public removeAllOptional(queryGraph: QueryGraph, options?: AxiosRequestConfig) {
        return QueryGraphOptionalApiFp(this.configuration).removeAllOptional(queryGraph, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove the triple pattern(s) identified by the `graphElementId` from all the optional that contains the graphElementId. - If it is a class the query parameter should be used and the triple pattern `?graphElementId rdf:type <classIRI>` will be moved from the optional to the bgp. - If it is a data property the tp `?graphElementIdVar1 <graphElementIdDataPropertyIRI> ?graphElementIdVar2` will be moved from the optional to the bgp. - If it is a object property the tps `?graphElementIdVar1 <graphElementIdDataPropertyIRI> ?graphElementIdVar2. ?graphElementIdVar2 rdf:type <classIRI>` will be moved from the optional to the bgp.
     * @summary Remove the graphElementId from the optional and move it back to the bgp.
     * @param {string} graphElementId The GraphElement that should be removed from the optional
     * @param {QueryGraph} queryGraph 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryGraphOptionalApi
     */
    public removeOptionalGraphElementId(graphElementId: string, queryGraph: QueryGraph, options?: AxiosRequestConfig) {
        return QueryGraphOptionalApiFp(this.configuration).removeOptionalGraphElementId(graphElementId, queryGraph, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StandaloneApi - axios parameter creator
 * @export
 */
export const StandaloneApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Return the graphol file as a string to be parsed by Grapholscape.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        standaloneOntologyGrapholGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/standalone/ontology/graphol`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Uploads a .graphol or .owl file. This will be used only by standalone Sparqling.
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        standaloneOntologyUploadPost: async (file?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/standalone/ontology/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StandaloneApi - functional programming interface
 * @export
 */
export const StandaloneApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StandaloneApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Return the graphol file as a string to be parsed by Grapholscape.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async standaloneOntologyGrapholGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.standaloneOntologyGrapholGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Uploads a .graphol or .owl file. This will be used only by standalone Sparqling.
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async standaloneOntologyUploadPost(file?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.standaloneOntologyUploadPost(file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StandaloneApi - factory interface
 * @export
 */
export const StandaloneApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StandaloneApiFp(configuration)
    return {
        /**
         * 
         * @summary Return the graphol file as a string to be parsed by Grapholscape.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        standaloneOntologyGrapholGet(options?: any): AxiosPromise<string> {
            return localVarFp.standaloneOntologyGrapholGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Uploads a .graphol or .owl file. This will be used only by standalone Sparqling.
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        standaloneOntologyUploadPost(file?: any, options?: any): AxiosPromise<void> {
            return localVarFp.standaloneOntologyUploadPost(file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StandaloneApi - object-oriented interface
 * @export
 * @class StandaloneApi
 * @extends {BaseAPI}
 */
export class StandaloneApi extends BaseAPI {
    /**
     * 
     * @summary Return the graphol file as a string to be parsed by Grapholscape.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StandaloneApi
     */
    public standaloneOntologyGrapholGet(options?: AxiosRequestConfig) {
        return StandaloneApiFp(this.configuration).standaloneOntologyGrapholGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Uploads a .graphol or .owl file. This will be used only by standalone Sparqling.
     * @param {any} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StandaloneApi
     */
    public standaloneOntologyUploadPost(file?: any, options?: AxiosRequestConfig) {
        return StandaloneApiFp(this.configuration).standaloneOntologyUploadPost(file, options).then((request) => request(this.axios, this.basePath));
    }
}


