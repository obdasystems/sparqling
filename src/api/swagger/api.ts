/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Swagger Sparqling WS
 * This server will expose an API to Sparqling front end to create new SPARQL queries with a combinations of point and click on the [GRAPHOLscape](https://github.com/obdasystems/grapholscape) graph.  Sparqling will be released as a standalone appication but also the server will embedded in [MWS](https://github.com/obdasystems/mws) and Sparqling will be integrated in [Monolith](https://www.monolith.obdasystems.com/).
 *
 * OpenAPI spec version: 1.0.0
 * Contact: info@obdasystems.com
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as isomorphicFetch from "isomorphic-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "http://localhost:7979/sparqling/1.0.0".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = isomorphicFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface BinaryExpression
 */
export interface BinaryExpression {
    /**
     * 
     * @type {string}
     * @memberof BinaryExpression
     */
    operator?: string;
    /**
     * Could be a value or a GraphElement id
     * @type {string}
     * @memberof BinaryExpression
     */
    leftOperand?: string;
    /**
     * Could be a value or a GraphElement id
     * @type {string}
     * @memberof BinaryExpression
     */
    rightOperand?: string;
}
/**
 * 
 * @export
 * @interface Branch
 */
export interface Branch {
    /**
     * 
     * @type {string}
     * @memberof Branch
     */
    objectPropertyIRI?: string;
    /**
     * It is true when domain and range are the same class.
     * @type {boolean}
     * @memberof Branch
     */
    cyclic?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Branch
     */
    direct?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof Branch
     */
    relatedClasses?: Array<string>;
}
/**
 * 
 * @export
 * @interface Entity
 */
export interface Entity {
    /**
     * 
     * @type {string}
     * @memberof Entity
     */
    type?: Entity.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Entity
     */
    iri?: string;
    /**
     * 
     * @type {string}
     * @memberof Entity
     */
    prefixedIri?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Entity
     */
    labels?: { [key: string]: string; };
}

/**
 * @export
 * @namespace Entity
 */
export namespace Entity {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Class = <any> 'class',
        ObjectProperty = <any> 'objectProperty',
        DataProperty = <any> 'dataProperty'
    }
}
/**
 * 
 * @export
 * @interface Filter
 */
export interface Filter {
    /**
     * 
     * @type {BinaryExpression}
     * @memberof Filter
     */
    expression?: BinaryExpression;
}
/**
 * 
 * @export
 * @interface GraphElement
 */
export interface GraphElement {
    /**
     * This id corrensopond to the variable when entity type is a class.
     * @type {string}
     * @memberof GraphElement
     */
    id?: string;
    /**
     * It could have more than one entity only when entity type is a class (could be derived after clicking on two borther classes)
     * @type {Array<Entity>}
     * @memberof GraphElement
     */
    entities?: Array<Entity>;
    /**
     * 
     * @type {Array<GraphElement>}
     * @memberof GraphElement
     */
    children?: Array<GraphElement>;
}
/**
 * 
 * @export
 * @interface GroupByElement
 */
export interface GroupByElement {
    /**
     * 
     * @type {Array<number>}
     * @memberof GroupByElement
     */
    headElementIds?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof GroupByElement
     */
    _function?: string;
}
/**
 * 
 * @export
 * @interface HeadElement
 */
export interface HeadElement {
    /**
     * 
     * @type {number}
     * @memberof HeadElement
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof HeadElement
     */
    graphElementId?: number;
    /**
     * 
     * @type {string}
     * @memberof HeadElement
     */
    _var?: string;
    /**
     * 
     * @type {string}
     * @memberof HeadElement
     */
    alias?: string;
    /**
     * 
     * @type {boolean}
     * @memberof HeadElement
     */
    hidden?: boolean;
}
/**
 * 
 * @export
 * @interface Highlights
 */
export interface Highlights {
    /**
     * Subclasses or brother classes
     * @type {Array<string>}
     * @memberof Highlights
     */
    classes?: Array<string>;
    /**
     * 
     * @type {Array<Branch>}
     * @memberof Highlights
     */
    objectProperties?: Array<Branch>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Highlights
     */
    dataProperties?: Array<string>;
}
/**
 * 
 * @export
 * @interface OntologyPath
 */
export interface OntologyPath {
    /**
     * Starts with lastSelectedIRI and ends with clickedIRI. In between the nodes and edges traversed in the path (ISA edge are marked as ISA)
     * @type {Array<string>}
     * @memberof OntologyPath
     */
    entities?: Array<string>;
}
/**
 * 
 * @export
 * @interface OntologyUploadBody
 */
export interface OntologyUploadBody {
    /**
     * 
     * @type {Blob}
     * @memberof OntologyUploadBody
     */
    file?: Blob;
}
/**
 * 
 * @export
 * @interface Optional
 */
export interface Optional {
    /**
     * 
     * @type {number}
     * @memberof Optional
     */
    id?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Optional
     */
    graphIds?: Array<string>;
}
/**
 * 
 * @export
 * @interface OrderByElement
 */
export interface OrderByElement {
    /**
     * 
     * @type {number}
     * @memberof OrderByElement
     */
    headElementId?: number;
    /**
     * 
     * @type {boolean}
     * @memberof OrderByElement
     */
    ascending?: boolean;
}
/**
 * 
 * @export
 */
export type Paths = Array<OntologyPath>
/**
 * 
 * @export
 * @interface QueryGraph
 */
export interface QueryGraph {
    /**
     * 
     * @type {boolean}
     * @memberof QueryGraph
     */
    distinct?: boolean;
    /**
     * 
     * @type {Array<HeadElement>}
     * @memberof QueryGraph
     */
    head: Array<HeadElement>;
    /**
     * 
     * @type {GraphElement}
     * @memberof QueryGraph
     */
    graph: GraphElement;
    /**
     * 
     * @type {Array<Filter>}
     * @memberof QueryGraph
     */
    filters?: Array<Filter>;
    /**
     * 
     * @type {Array<Optional>}
     * @memberof QueryGraph
     */
    optionals?: Array<Optional>;
    /**
     * 
     * @type {GraphElement}
     * @memberof QueryGraph
     */
    minus?: GraphElement;
    /**
     * 
     * @type {OrderByElement}
     * @memberof QueryGraph
     */
    orderBy?: OrderByElement;
    /**
     * 
     * @type {GroupByElement}
     * @memberof QueryGraph
     */
    groupBy?: GroupByElement;
    /**
     * 
     * @type {Array<Filter>}
     * @memberof QueryGraph
     */
    having?: Array<Filter>;
    /**
     * 
     * @type {string}
     * @memberof QueryGraph
     */
    sparql: string;
}
/**
 * 
 * @export
 * @interface Schema
 */
export interface Schema {
    /**
     * 
     * @type {number}
     * @memberof Schema
     */
    id?: number;
}
/**
 * OntologyGraphApi - fetch parameter creator
 * @export
 */
export const OntologyGraphApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This route is used to highlight the negihbours of the selected class. The neighbours can be classes (brother classes or child classes), object properties (the class or one of his father partecipate or are typed to domain/range) or data properties (the class or one of its fathers partecipates or is typed to its domain).
         * @summary Get the IRIs of the ontology entities \"related\" to the clicked and selected.
         * @param {string} clickedClassIRI The IRI of the class just clicked on the GRAPHOLscape ontology graph
         * @param {Array<string>} [params] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        highligths(clickedClassIRI: string, params?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'clickedClassIRI' is not null or undefined
            if (clickedClassIRI === null || clickedClassIRI === undefined) {
                throw new RequiredError('clickedClassIRI','Required parameter clickedClassIRI was null or undefined when calling highligths.');
            }
            const localVarPath = `/highlights`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (clickedClassIRI !== undefined) {
                localVarQueryParameter['clickedClassIRI'] = clickedClassIRI;
            }

            if (params) {
                localVarQueryParameter['params'] = params;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The results should be based on Dijkstra algorithm for shortest paths. ISA wieght is 0 while role weight is 1.
         * @summary Find paths between selected class and clicked class.
         * @param {string} lastSelectedIRI The IRI of the entity clicked on the GRAPHOLscape ontology graph
         * @param {string} clickedIRI The IRI of the entity clicked on the GRAPHOLscape ontology graph
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        highligthsPaths(lastSelectedIRI: string, clickedIRI: string, options: any = {}): FetchArgs {
            // verify required parameter 'lastSelectedIRI' is not null or undefined
            if (lastSelectedIRI === null || lastSelectedIRI === undefined) {
                throw new RequiredError('lastSelectedIRI','Required parameter lastSelectedIRI was null or undefined when calling highligthsPaths.');
            }
            // verify required parameter 'clickedIRI' is not null or undefined
            if (clickedIRI === null || clickedIRI === undefined) {
                throw new RequiredError('clickedIRI','Required parameter clickedIRI was null or undefined when calling highligthsPaths.');
            }
            const localVarPath = `/highlights/paths`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (lastSelectedIRI !== undefined) {
                localVarQueryParameter['lastSelectedIRI'] = lastSelectedIRI;
            }

            if (clickedIRI !== undefined) {
                localVarQueryParameter['clickedIRI'] = clickedIRI;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OntologyGraphApi - functional programming interface
 * @export
 */
export const OntologyGraphApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This route is used to highlight the negihbours of the selected class. The neighbours can be classes (brother classes or child classes), object properties (the class or one of his father partecipate or are typed to domain/range) or data properties (the class or one of its fathers partecipates or is typed to its domain).
         * @summary Get the IRIs of the ontology entities \"related\" to the clicked and selected.
         * @param {string} clickedClassIRI The IRI of the class just clicked on the GRAPHOLscape ontology graph
         * @param {Array<string>} [params] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        highligths(clickedClassIRI: string, params?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Highlights> {
            const localVarFetchArgs = OntologyGraphApiFetchParamCreator(configuration).highligths(clickedClassIRI, params, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The results should be based on Dijkstra algorithm for shortest paths. ISA wieght is 0 while role weight is 1.
         * @summary Find paths between selected class and clicked class.
         * @param {string} lastSelectedIRI The IRI of the entity clicked on the GRAPHOLscape ontology graph
         * @param {string} clickedIRI The IRI of the entity clicked on the GRAPHOLscape ontology graph
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        highligthsPaths(lastSelectedIRI: string, clickedIRI: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Paths> {
            const localVarFetchArgs = OntologyGraphApiFetchParamCreator(configuration).highligthsPaths(lastSelectedIRI, clickedIRI, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * OntologyGraphApi - factory interface
 * @export
 */
export const OntologyGraphApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * This route is used to highlight the negihbours of the selected class. The neighbours can be classes (brother classes or child classes), object properties (the class or one of his father partecipate or are typed to domain/range) or data properties (the class or one of its fathers partecipates or is typed to its domain).
         * @summary Get the IRIs of the ontology entities \"related\" to the clicked and selected.
         * @param {string} clickedClassIRI The IRI of the class just clicked on the GRAPHOLscape ontology graph
         * @param {Array<string>} [params] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        highligths(clickedClassIRI: string, params?: Array<string>, options?: any) {
            return OntologyGraphApiFp(configuration).highligths(clickedClassIRI, params, options)(fetch, basePath);
        },
        /**
         * The results should be based on Dijkstra algorithm for shortest paths. ISA wieght is 0 while role weight is 1.
         * @summary Find paths between selected class and clicked class.
         * @param {string} lastSelectedIRI The IRI of the entity clicked on the GRAPHOLscape ontology graph
         * @param {string} clickedIRI The IRI of the entity clicked on the GRAPHOLscape ontology graph
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        highligthsPaths(lastSelectedIRI: string, clickedIRI: string, options?: any) {
            return OntologyGraphApiFp(configuration).highligthsPaths(lastSelectedIRI, clickedIRI, options)(fetch, basePath);
        },
    };
};

/**
 * OntologyGraphApi - object-oriented interface
 * @export
 * @class OntologyGraphApi
 * @extends {BaseAPI}
 */
export class OntologyGraphApi extends BaseAPI {
    /**
     * This route is used to highlight the negihbours of the selected class. The neighbours can be classes (brother classes or child classes), object properties (the class or one of his father partecipate or are typed to domain/range) or data properties (the class or one of its fathers partecipates or is typed to its domain).
     * @summary Get the IRIs of the ontology entities \"related\" to the clicked and selected.
     * @param {string} clickedClassIRI The IRI of the class just clicked on the GRAPHOLscape ontology graph
     * @param {Array<string>} [params] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyGraphApi
     */
    public highligths(clickedClassIRI: string, params?: Array<string>, options?: any) {
        return OntologyGraphApiFp(this.configuration).highligths(clickedClassIRI, params, options)(this.fetch, this.basePath);
    }

    /**
     * The results should be based on Dijkstra algorithm for shortest paths. ISA wieght is 0 while role weight is 1.
     * @summary Find paths between selected class and clicked class.
     * @param {string} lastSelectedIRI The IRI of the entity clicked on the GRAPHOLscape ontology graph
     * @param {string} clickedIRI The IRI of the entity clicked on the GRAPHOLscape ontology graph
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OntologyGraphApi
     */
    public highligthsPaths(lastSelectedIRI: string, clickedIRI: string, options?: any) {
        return OntologyGraphApiFp(this.configuration).highligthsPaths(lastSelectedIRI, clickedIRI, options)(this.fetch, this.basePath);
    }

}
/**
 * QueryGraphApi - fetch parameter creator
 * @export
 */
export const QueryGraphApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Explicitley add a term to the query head. All the data property variables are added automatically to the head during the query graph construction. This will add to the head only variables associated to classes (`rdf:type` triple pattern) or data properties.
         * @summary Add the head term to the query graph.
         * @param {QueryGraph} body 
         * @param {string} graphElementId The id of the graph node that should be added to the head
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addHeadTerm(body: QueryGraph, graphElementId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling addHeadTerm.');
            }
            // verify required parameter 'graphElementId' is not null or undefined
            if (graphElementId === null || graphElementId === undefined) {
                throw new RequiredError('graphElementId','Required parameter graphElementId was null or undefined when calling addHeadTerm.');
            }
            const localVarPath = `/queryGraph/head/add/{graphElementId}`
                .replace(`{${"graphElementId"}}`, encodeURIComponent(String(graphElementId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"QueryGraph" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This path should be used to build the query graph using the path interaction. As a result there will be added to the query several triple pattern (depending on the length of the path) as a sequence of classes and object properties. Data properties never appear in paths, in order to add them use the simple PUT route.
         * @summary Get the query graph that will be rendered by Sparqling, the query head, the sparql code based on the chosen path.
         * @param {QueryGraph} body 
         * @param {string} path Serialization of Path object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPathToQueryGraph(body: QueryGraph, path: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling addPathToQueryGraph.');
            }
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling addPathToQueryGraph.');
            }
            const localVarPath = `/queryGraph/path`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"QueryGraph" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This route is used when the user wants to delete a node from the query graph. All the children of this node will be deleted as well as we do not want to create query with completly separated branches. All the variables that are going to be deleted should also be deleted from the head of the query. **WARNING**, if the node has multiple occurrences (due to join operations) every node should be deleted.
         * @summary Delete the GraphElement (and all its children) from the query graph and head.
         * @param {QueryGraph} body 
         * @param {string} graphElementId The GraphElement that should be delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGraphElementId(body: QueryGraph, graphElementId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling deleteGraphElementId.');
            }
            // verify required parameter 'graphElementId' is not null or undefined
            if (graphElementId === null || graphElementId === undefined) {
                throw new RequiredError('graphElementId','Required parameter graphElementId was null or undefined when calling deleteGraphElementId.');
            }
            const localVarPath = `/queryGraph/node/delete/{graphElementId}`
                .replace(`{${"graphElementId"}}`, encodeURIComponent(String(graphElementId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"QueryGraph" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete the head term from the query graph.
         * @param {QueryGraph} body 
         * @param {string} headTerm The head term that should be delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHeadTerm(body: QueryGraph, headTerm: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling deleteHeadTerm.');
            }
            // verify required parameter 'headTerm' is not null or undefined
            if (headTerm === null || headTerm === undefined) {
                throw new RequiredError('headTerm','Required parameter headTerm was null or undefined when calling deleteHeadTerm.');
            }
            const localVarPath = `/queryGraph/head/delete/{headTerm}`
                .replace(`{${"headTerm"}}`, encodeURIComponent(String(headTerm)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"QueryGraph" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Starting from only the clicked class get the query graph that will be rendered by Sparqling, the query head, the sparql code. The sparql query returned will be somthing like `select ?x { ?x a <clickedClassIRI>` }. The variable `?x` should be called according to the entity remainder or label. The variable will be added to the head of the query in order to create a valid SPARQL query.
         * @summary This is the first route to call in order to build the query graph.
         * @param {string} clickedClassIRI The IRI of the entity clicked on the GRAPHOLscape ontology graph
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueryGraph(clickedClassIRI: string, options: any = {}): FetchArgs {
            // verify required parameter 'clickedClassIRI' is not null or undefined
            if (clickedClassIRI === null || clickedClassIRI === undefined) {
                throw new RequiredError('clickedClassIRI','Required parameter clickedClassIRI was null or undefined when calling getQueryGraph.');
            }
            const localVarPath = `/queryGraph/node`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (clickedClassIRI !== undefined) {
                localVarQueryParameter['clickedClassIRI'] = clickedClassIRI;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This route will return the same query graph passed in the body but the SPARQL code with the new filters optionals group by and havings. Note that if the filters are related to optional variables they should be put inside the optional block.
         * @summary Translate the query graph in sparql.
         * @param {QueryGraph} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyFilters(body: QueryGraph, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling modifyFilters.');
            }
            const localVarPath = `/queryGraph/translate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"QueryGraph" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This call is used when the user click on a highlighted class and should add a triple pattern of the form like `?x rdf:type <targetClassIRI>`. The server should find `?x` in the SPARQL code as the variable associated to the `sourceClassIRI`.
         * @summary Starting from the current query graph continue to build the query graph through a class.
         * @param {QueryGraph} body 
         * @param {string} graphElementId The id of the node of the selected class in the query graph.
         * @param {string} sourceClassIRI The IRI of the last selected class. It could be selected from the ontology graph or from the query graph.
         * @param {string} targetClassIRI The IRI of the entity clicked on the GRAPHOLscape ontology graph.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putQueryGraphClass(body: QueryGraph, graphElementId: string, sourceClassIRI: string, targetClassIRI: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling putQueryGraphClass.');
            }
            // verify required parameter 'graphElementId' is not null or undefined
            if (graphElementId === null || graphElementId === undefined) {
                throw new RequiredError('graphElementId','Required parameter graphElementId was null or undefined when calling putQueryGraphClass.');
            }
            // verify required parameter 'sourceClassIRI' is not null or undefined
            if (sourceClassIRI === null || sourceClassIRI === undefined) {
                throw new RequiredError('sourceClassIRI','Required parameter sourceClassIRI was null or undefined when calling putQueryGraphClass.');
            }
            // verify required parameter 'targetClassIRI' is not null or undefined
            if (targetClassIRI === null || targetClassIRI === undefined) {
                throw new RequiredError('targetClassIRI','Required parameter targetClassIRI was null or undefined when calling putQueryGraphClass.');
            }
            const localVarPath = `/queryGraph/node/class/{graphElementId}`
                .replace(`{${"graphElementId"}}`, encodeURIComponent(String(graphElementId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sourceClassIRI !== undefined) {
                localVarQueryParameter['sourceClassIRI'] = sourceClassIRI;
            }

            if (targetClassIRI !== undefined) {
                localVarQueryParameter['targetClassIRI'] = targetClassIRI;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"QueryGraph" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This route is used when the user click a highlighted data property. The triple pattern to add is something like `?x <predicateIRI> ?y` where `?x` should be derived from `selectedClassIRI`. Note that `?y` is fresh new variable that should be added also to the head of the query (we assume data property values are interesting). The variable `?y` should be called according to the entity remainder or label and should add a counter if there is an already defined variable for that data property.
         * @summary Starting from the current query graph continue to build the query graph through a data property.
         * @param {QueryGraph} body 
         * @param {string} graphElementId The id of the node of the selected class in the query graph.
         * @param {string} sourceClassIRI The IRI of the last selected class. It could be selected from the ontology graph or from the query graph.
         * @param {string} predicateIRI The IRI of the clicked data property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putQueryGraphDataProperty(body: QueryGraph, graphElementId: string, sourceClassIRI: string, predicateIRI: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling putQueryGraphDataProperty.');
            }
            // verify required parameter 'graphElementId' is not null or undefined
            if (graphElementId === null || graphElementId === undefined) {
                throw new RequiredError('graphElementId','Required parameter graphElementId was null or undefined when calling putQueryGraphDataProperty.');
            }
            // verify required parameter 'sourceClassIRI' is not null or undefined
            if (sourceClassIRI === null || sourceClassIRI === undefined) {
                throw new RequiredError('sourceClassIRI','Required parameter sourceClassIRI was null or undefined when calling putQueryGraphDataProperty.');
            }
            // verify required parameter 'predicateIRI' is not null or undefined
            if (predicateIRI === null || predicateIRI === undefined) {
                throw new RequiredError('predicateIRI','Required parameter predicateIRI was null or undefined when calling putQueryGraphDataProperty.');
            }
            const localVarPath = `/queryGraph/node/dataProperty/{graphElementId}`
                .replace(`{${"graphElementId"}}`, encodeURIComponent(String(graphElementId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sourceClassIRI !== undefined) {
                localVarQueryParameter['sourceClassIRI'] = sourceClassIRI;
            }

            if (predicateIRI !== undefined) {
                localVarQueryParameter['predicateIRI'] = predicateIRI;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"QueryGraph" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Starting from a query graph which has two nodes representing the same class, it returns the query graph in which the two nodes have been joined into a single one. The children of the selected nodes will be grouped in `graphElementId1` and each time we add a children through the previous routes they will be added to this node.
         * @summary Join two GraphNodeElement in one. graph through a data property.
         * @param {QueryGraph} body 
         * @param {string} graphElementId1 The id of the node of the selected class in the query graph.
         * @param {string} graphElementId2 The id of the node of the selected class in the query graph.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putQueryGraphJoin(body: QueryGraph, graphElementId1: string, graphElementId2: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling putQueryGraphJoin.');
            }
            // verify required parameter 'graphElementId1' is not null or undefined
            if (graphElementId1 === null || graphElementId1 === undefined) {
                throw new RequiredError('graphElementId1','Required parameter graphElementId1 was null or undefined when calling putQueryGraphJoin.');
            }
            // verify required parameter 'graphElementId2' is not null or undefined
            if (graphElementId2 === null || graphElementId2 === undefined) {
                throw new RequiredError('graphElementId2','Required parameter graphElementId2 was null or undefined when calling putQueryGraphJoin.');
            }
            const localVarPath = `/queryGraph/node/join/{graphElementId1}/{graphElementId2}`
                .replace(`{${"graphElementId1"}}`, encodeURIComponent(String(graphElementId1)))
                .replace(`{${"graphElementId2"}}`, encodeURIComponent(String(graphElementId2)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"QueryGraph" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This route is used when the user click a highlighted object property with ornly one `relatedClasses` or, in the case of more than one `relatedClasses` immediatly after choosing one of them. In this case the triple pattern to add is something like `?x <predicateIRI> ?y` where `?x` and `?y` should be derived from the direction indicated by `isPredicateDirect` of the object property with respect to `sourceClassIRI` and `targetClassIRI`. If there is a cyclic object property the user also should specify the direction if order to correctly assign `?x` and `?y`. Either `?x` or `?y` should be a fresh new variable which should be linked to a new triple pattern `?y rdf:type <targetClassIRI>`. The variable `?y` should be called according to the entity remainder or label and should add a counter if there is an already defined variable for that class.
         * @summary Starting from the current query graph continue to build the query graph through a object property.
         * @param {QueryGraph} body 
         * @param {string} graphElementId The id of the node of the selected class in the query graph.
         * @param {string} sourceClassIRI The IRI of the last selected class. It could be selected from the ontology graph or from the query graph.
         * @param {string} predicateIRI The IRI of the predicate which links source class and target class
         * @param {string} targetClassIRI The IRI of the entity clicked on the GRAPHOLscape ontology graph.
         * @param {boolean} isPredicateDirect If true sourceClassIRI is the domain of predicateIRI, if false sourceClassIRI is the range of predicateIRI.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putQueryGraphObjectProperty(body: QueryGraph, graphElementId: string, sourceClassIRI: string, predicateIRI: string, targetClassIRI: string, isPredicateDirect: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling putQueryGraphObjectProperty.');
            }
            // verify required parameter 'graphElementId' is not null or undefined
            if (graphElementId === null || graphElementId === undefined) {
                throw new RequiredError('graphElementId','Required parameter graphElementId was null or undefined when calling putQueryGraphObjectProperty.');
            }
            // verify required parameter 'sourceClassIRI' is not null or undefined
            if (sourceClassIRI === null || sourceClassIRI === undefined) {
                throw new RequiredError('sourceClassIRI','Required parameter sourceClassIRI was null or undefined when calling putQueryGraphObjectProperty.');
            }
            // verify required parameter 'predicateIRI' is not null or undefined
            if (predicateIRI === null || predicateIRI === undefined) {
                throw new RequiredError('predicateIRI','Required parameter predicateIRI was null or undefined when calling putQueryGraphObjectProperty.');
            }
            // verify required parameter 'targetClassIRI' is not null or undefined
            if (targetClassIRI === null || targetClassIRI === undefined) {
                throw new RequiredError('targetClassIRI','Required parameter targetClassIRI was null or undefined when calling putQueryGraphObjectProperty.');
            }
            // verify required parameter 'isPredicateDirect' is not null or undefined
            if (isPredicateDirect === null || isPredicateDirect === undefined) {
                throw new RequiredError('isPredicateDirect','Required parameter isPredicateDirect was null or undefined when calling putQueryGraphObjectProperty.');
            }
            const localVarPath = `/queryGraph/node/objectProperty/{graphElementId}`
                .replace(`{${"graphElementId"}}`, encodeURIComponent(String(graphElementId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sourceClassIRI !== undefined) {
                localVarQueryParameter['sourceClassIRI'] = sourceClassIRI;
            }

            if (predicateIRI !== undefined) {
                localVarQueryParameter['predicateIRI'] = predicateIRI;
            }

            if (targetClassIRI !== undefined) {
                localVarQueryParameter['targetClassIRI'] = targetClassIRI;
            }

            if (isPredicateDirect !== undefined) {
                localVarQueryParameter['isPredicateDirect'] = isPredicateDirect;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"QueryGraph" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QueryGraphApi - functional programming interface
 * @export
 */
export const QueryGraphApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Explicitley add a term to the query head. All the data property variables are added automatically to the head during the query graph construction. This will add to the head only variables associated to classes (`rdf:type` triple pattern) or data properties.
         * @summary Add the head term to the query graph.
         * @param {QueryGraph} body 
         * @param {string} graphElementId The id of the graph node that should be added to the head
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addHeadTerm(body: QueryGraph, graphElementId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QueryGraph> {
            const localVarFetchArgs = QueryGraphApiFetchParamCreator(configuration).addHeadTerm(body, graphElementId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This path should be used to build the query graph using the path interaction. As a result there will be added to the query several triple pattern (depending on the length of the path) as a sequence of classes and object properties. Data properties never appear in paths, in order to add them use the simple PUT route.
         * @summary Get the query graph that will be rendered by Sparqling, the query head, the sparql code based on the chosen path.
         * @param {QueryGraph} body 
         * @param {string} path Serialization of Path object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPathToQueryGraph(body: QueryGraph, path: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QueryGraph> {
            const localVarFetchArgs = QueryGraphApiFetchParamCreator(configuration).addPathToQueryGraph(body, path, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This route is used when the user wants to delete a node from the query graph. All the children of this node will be deleted as well as we do not want to create query with completly separated branches. All the variables that are going to be deleted should also be deleted from the head of the query. **WARNING**, if the node has multiple occurrences (due to join operations) every node should be deleted.
         * @summary Delete the GraphElement (and all its children) from the query graph and head.
         * @param {QueryGraph} body 
         * @param {string} graphElementId The GraphElement that should be delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGraphElementId(body: QueryGraph, graphElementId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QueryGraph> {
            const localVarFetchArgs = QueryGraphApiFetchParamCreator(configuration).deleteGraphElementId(body, graphElementId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete the head term from the query graph.
         * @param {QueryGraph} body 
         * @param {string} headTerm The head term that should be delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHeadTerm(body: QueryGraph, headTerm: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QueryGraph> {
            const localVarFetchArgs = QueryGraphApiFetchParamCreator(configuration).deleteHeadTerm(body, headTerm, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Starting from only the clicked class get the query graph that will be rendered by Sparqling, the query head, the sparql code. The sparql query returned will be somthing like `select ?x { ?x a <clickedClassIRI>` }. The variable `?x` should be called according to the entity remainder or label. The variable will be added to the head of the query in order to create a valid SPARQL query.
         * @summary This is the first route to call in order to build the query graph.
         * @param {string} clickedClassIRI The IRI of the entity clicked on the GRAPHOLscape ontology graph
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueryGraph(clickedClassIRI: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QueryGraph> {
            const localVarFetchArgs = QueryGraphApiFetchParamCreator(configuration).getQueryGraph(clickedClassIRI, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This route will return the same query graph passed in the body but the SPARQL code with the new filters optionals group by and havings. Note that if the filters are related to optional variables they should be put inside the optional block.
         * @summary Translate the query graph in sparql.
         * @param {QueryGraph} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyFilters(body: QueryGraph, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QueryGraph> {
            const localVarFetchArgs = QueryGraphApiFetchParamCreator(configuration).modifyFilters(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This call is used when the user click on a highlighted class and should add a triple pattern of the form like `?x rdf:type <targetClassIRI>`. The server should find `?x` in the SPARQL code as the variable associated to the `sourceClassIRI`.
         * @summary Starting from the current query graph continue to build the query graph through a class.
         * @param {QueryGraph} body 
         * @param {string} graphElementId The id of the node of the selected class in the query graph.
         * @param {string} sourceClassIRI The IRI of the last selected class. It could be selected from the ontology graph or from the query graph.
         * @param {string} targetClassIRI The IRI of the entity clicked on the GRAPHOLscape ontology graph.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putQueryGraphClass(body: QueryGraph, graphElementId: string, sourceClassIRI: string, targetClassIRI: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QueryGraph> {
            const localVarFetchArgs = QueryGraphApiFetchParamCreator(configuration).putQueryGraphClass(body, graphElementId, sourceClassIRI, targetClassIRI, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This route is used when the user click a highlighted data property. The triple pattern to add is something like `?x <predicateIRI> ?y` where `?x` should be derived from `selectedClassIRI`. Note that `?y` is fresh new variable that should be added also to the head of the query (we assume data property values are interesting). The variable `?y` should be called according to the entity remainder or label and should add a counter if there is an already defined variable for that data property.
         * @summary Starting from the current query graph continue to build the query graph through a data property.
         * @param {QueryGraph} body 
         * @param {string} graphElementId The id of the node of the selected class in the query graph.
         * @param {string} sourceClassIRI The IRI of the last selected class. It could be selected from the ontology graph or from the query graph.
         * @param {string} predicateIRI The IRI of the clicked data property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putQueryGraphDataProperty(body: QueryGraph, graphElementId: string, sourceClassIRI: string, predicateIRI: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QueryGraph> {
            const localVarFetchArgs = QueryGraphApiFetchParamCreator(configuration).putQueryGraphDataProperty(body, graphElementId, sourceClassIRI, predicateIRI, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Starting from a query graph which has two nodes representing the same class, it returns the query graph in which the two nodes have been joined into a single one. The children of the selected nodes will be grouped in `graphElementId1` and each time we add a children through the previous routes they will be added to this node.
         * @summary Join two GraphNodeElement in one. graph through a data property.
         * @param {QueryGraph} body 
         * @param {string} graphElementId1 The id of the node of the selected class in the query graph.
         * @param {string} graphElementId2 The id of the node of the selected class in the query graph.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putQueryGraphJoin(body: QueryGraph, graphElementId1: string, graphElementId2: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QueryGraph> {
            const localVarFetchArgs = QueryGraphApiFetchParamCreator(configuration).putQueryGraphJoin(body, graphElementId1, graphElementId2, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This route is used when the user click a highlighted object property with ornly one `relatedClasses` or, in the case of more than one `relatedClasses` immediatly after choosing one of them. In this case the triple pattern to add is something like `?x <predicateIRI> ?y` where `?x` and `?y` should be derived from the direction indicated by `isPredicateDirect` of the object property with respect to `sourceClassIRI` and `targetClassIRI`. If there is a cyclic object property the user also should specify the direction if order to correctly assign `?x` and `?y`. Either `?x` or `?y` should be a fresh new variable which should be linked to a new triple pattern `?y rdf:type <targetClassIRI>`. The variable `?y` should be called according to the entity remainder or label and should add a counter if there is an already defined variable for that class.
         * @summary Starting from the current query graph continue to build the query graph through a object property.
         * @param {QueryGraph} body 
         * @param {string} graphElementId The id of the node of the selected class in the query graph.
         * @param {string} sourceClassIRI The IRI of the last selected class. It could be selected from the ontology graph or from the query graph.
         * @param {string} predicateIRI The IRI of the predicate which links source class and target class
         * @param {string} targetClassIRI The IRI of the entity clicked on the GRAPHOLscape ontology graph.
         * @param {boolean} isPredicateDirect If true sourceClassIRI is the domain of predicateIRI, if false sourceClassIRI is the range of predicateIRI.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putQueryGraphObjectProperty(body: QueryGraph, graphElementId: string, sourceClassIRI: string, predicateIRI: string, targetClassIRI: string, isPredicateDirect: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QueryGraph> {
            const localVarFetchArgs = QueryGraphApiFetchParamCreator(configuration).putQueryGraphObjectProperty(body, graphElementId, sourceClassIRI, predicateIRI, targetClassIRI, isPredicateDirect, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * QueryGraphApi - factory interface
 * @export
 */
export const QueryGraphApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Explicitley add a term to the query head. All the data property variables are added automatically to the head during the query graph construction. This will add to the head only variables associated to classes (`rdf:type` triple pattern) or data properties.
         * @summary Add the head term to the query graph.
         * @param {QueryGraph} body 
         * @param {string} graphElementId The id of the graph node that should be added to the head
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addHeadTerm(body: QueryGraph, graphElementId: string, options?: any) {
            return QueryGraphApiFp(configuration).addHeadTerm(body, graphElementId, options)(fetch, basePath);
        },
        /**
         * This path should be used to build the query graph using the path interaction. As a result there will be added to the query several triple pattern (depending on the length of the path) as a sequence of classes and object properties. Data properties never appear in paths, in order to add them use the simple PUT route.
         * @summary Get the query graph that will be rendered by Sparqling, the query head, the sparql code based on the chosen path.
         * @param {QueryGraph} body 
         * @param {string} path Serialization of Path object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPathToQueryGraph(body: QueryGraph, path: string, options?: any) {
            return QueryGraphApiFp(configuration).addPathToQueryGraph(body, path, options)(fetch, basePath);
        },
        /**
         * This route is used when the user wants to delete a node from the query graph. All the children of this node will be deleted as well as we do not want to create query with completly separated branches. All the variables that are going to be deleted should also be deleted from the head of the query. **WARNING**, if the node has multiple occurrences (due to join operations) every node should be deleted.
         * @summary Delete the GraphElement (and all its children) from the query graph and head.
         * @param {QueryGraph} body 
         * @param {string} graphElementId The GraphElement that should be delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGraphElementId(body: QueryGraph, graphElementId: string, options?: any) {
            return QueryGraphApiFp(configuration).deleteGraphElementId(body, graphElementId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete the head term from the query graph.
         * @param {QueryGraph} body 
         * @param {string} headTerm The head term that should be delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHeadTerm(body: QueryGraph, headTerm: string, options?: any) {
            return QueryGraphApiFp(configuration).deleteHeadTerm(body, headTerm, options)(fetch, basePath);
        },
        /**
         * Starting from only the clicked class get the query graph that will be rendered by Sparqling, the query head, the sparql code. The sparql query returned will be somthing like `select ?x { ?x a <clickedClassIRI>` }. The variable `?x` should be called according to the entity remainder or label. The variable will be added to the head of the query in order to create a valid SPARQL query.
         * @summary This is the first route to call in order to build the query graph.
         * @param {string} clickedClassIRI The IRI of the entity clicked on the GRAPHOLscape ontology graph
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueryGraph(clickedClassIRI: string, options?: any) {
            return QueryGraphApiFp(configuration).getQueryGraph(clickedClassIRI, options)(fetch, basePath);
        },
        /**
         * This route will return the same query graph passed in the body but the SPARQL code with the new filters optionals group by and havings. Note that if the filters are related to optional variables they should be put inside the optional block.
         * @summary Translate the query graph in sparql.
         * @param {QueryGraph} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyFilters(body: QueryGraph, options?: any) {
            return QueryGraphApiFp(configuration).modifyFilters(body, options)(fetch, basePath);
        },
        /**
         * This call is used when the user click on a highlighted class and should add a triple pattern of the form like `?x rdf:type <targetClassIRI>`. The server should find `?x` in the SPARQL code as the variable associated to the `sourceClassIRI`.
         * @summary Starting from the current query graph continue to build the query graph through a class.
         * @param {QueryGraph} body 
         * @param {string} graphElementId The id of the node of the selected class in the query graph.
         * @param {string} sourceClassIRI The IRI of the last selected class. It could be selected from the ontology graph or from the query graph.
         * @param {string} targetClassIRI The IRI of the entity clicked on the GRAPHOLscape ontology graph.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putQueryGraphClass(body: QueryGraph, graphElementId: string, sourceClassIRI: string, targetClassIRI: string, options?: any) {
            return QueryGraphApiFp(configuration).putQueryGraphClass(body, graphElementId, sourceClassIRI, targetClassIRI, options)(fetch, basePath);
        },
        /**
         * This route is used when the user click a highlighted data property. The triple pattern to add is something like `?x <predicateIRI> ?y` where `?x` should be derived from `selectedClassIRI`. Note that `?y` is fresh new variable that should be added also to the head of the query (we assume data property values are interesting). The variable `?y` should be called according to the entity remainder or label and should add a counter if there is an already defined variable for that data property.
         * @summary Starting from the current query graph continue to build the query graph through a data property.
         * @param {QueryGraph} body 
         * @param {string} graphElementId The id of the node of the selected class in the query graph.
         * @param {string} sourceClassIRI The IRI of the last selected class. It could be selected from the ontology graph or from the query graph.
         * @param {string} predicateIRI The IRI of the clicked data property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putQueryGraphDataProperty(body: QueryGraph, graphElementId: string, sourceClassIRI: string, predicateIRI: string, options?: any) {
            return QueryGraphApiFp(configuration).putQueryGraphDataProperty(body, graphElementId, sourceClassIRI, predicateIRI, options)(fetch, basePath);
        },
        /**
         * Starting from a query graph which has two nodes representing the same class, it returns the query graph in which the two nodes have been joined into a single one. The children of the selected nodes will be grouped in `graphElementId1` and each time we add a children through the previous routes they will be added to this node.
         * @summary Join two GraphNodeElement in one. graph through a data property.
         * @param {QueryGraph} body 
         * @param {string} graphElementId1 The id of the node of the selected class in the query graph.
         * @param {string} graphElementId2 The id of the node of the selected class in the query graph.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putQueryGraphJoin(body: QueryGraph, graphElementId1: string, graphElementId2: string, options?: any) {
            return QueryGraphApiFp(configuration).putQueryGraphJoin(body, graphElementId1, graphElementId2, options)(fetch, basePath);
        },
        /**
         * This route is used when the user click a highlighted object property with ornly one `relatedClasses` or, in the case of more than one `relatedClasses` immediatly after choosing one of them. In this case the triple pattern to add is something like `?x <predicateIRI> ?y` where `?x` and `?y` should be derived from the direction indicated by `isPredicateDirect` of the object property with respect to `sourceClassIRI` and `targetClassIRI`. If there is a cyclic object property the user also should specify the direction if order to correctly assign `?x` and `?y`. Either `?x` or `?y` should be a fresh new variable which should be linked to a new triple pattern `?y rdf:type <targetClassIRI>`. The variable `?y` should be called according to the entity remainder or label and should add a counter if there is an already defined variable for that class.
         * @summary Starting from the current query graph continue to build the query graph through a object property.
         * @param {QueryGraph} body 
         * @param {string} graphElementId The id of the node of the selected class in the query graph.
         * @param {string} sourceClassIRI The IRI of the last selected class. It could be selected from the ontology graph or from the query graph.
         * @param {string} predicateIRI The IRI of the predicate which links source class and target class
         * @param {string} targetClassIRI The IRI of the entity clicked on the GRAPHOLscape ontology graph.
         * @param {boolean} isPredicateDirect If true sourceClassIRI is the domain of predicateIRI, if false sourceClassIRI is the range of predicateIRI.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putQueryGraphObjectProperty(body: QueryGraph, graphElementId: string, sourceClassIRI: string, predicateIRI: string, targetClassIRI: string, isPredicateDirect: boolean, options?: any) {
            return QueryGraphApiFp(configuration).putQueryGraphObjectProperty(body, graphElementId, sourceClassIRI, predicateIRI, targetClassIRI, isPredicateDirect, options)(fetch, basePath);
        },
    };
};

/**
 * QueryGraphApi - object-oriented interface
 * @export
 * @class QueryGraphApi
 * @extends {BaseAPI}
 */
export class QueryGraphApi extends BaseAPI {
    /**
     * Explicitley add a term to the query head. All the data property variables are added automatically to the head during the query graph construction. This will add to the head only variables associated to classes (`rdf:type` triple pattern) or data properties.
     * @summary Add the head term to the query graph.
     * @param {QueryGraph} body 
     * @param {string} graphElementId The id of the graph node that should be added to the head
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryGraphApi
     */
    public addHeadTerm(body: QueryGraph, graphElementId: string, options?: any) {
        return QueryGraphApiFp(this.configuration).addHeadTerm(body, graphElementId, options)(this.fetch, this.basePath);
    }

    /**
     * This path should be used to build the query graph using the path interaction. As a result there will be added to the query several triple pattern (depending on the length of the path) as a sequence of classes and object properties. Data properties never appear in paths, in order to add them use the simple PUT route.
     * @summary Get the query graph that will be rendered by Sparqling, the query head, the sparql code based on the chosen path.
     * @param {QueryGraph} body 
     * @param {string} path Serialization of Path object.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryGraphApi
     */
    public addPathToQueryGraph(body: QueryGraph, path: string, options?: any) {
        return QueryGraphApiFp(this.configuration).addPathToQueryGraph(body, path, options)(this.fetch, this.basePath);
    }

    /**
     * This route is used when the user wants to delete a node from the query graph. All the children of this node will be deleted as well as we do not want to create query with completly separated branches. All the variables that are going to be deleted should also be deleted from the head of the query. **WARNING**, if the node has multiple occurrences (due to join operations) every node should be deleted.
     * @summary Delete the GraphElement (and all its children) from the query graph and head.
     * @param {QueryGraph} body 
     * @param {string} graphElementId The GraphElement that should be delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryGraphApi
     */
    public deleteGraphElementId(body: QueryGraph, graphElementId: string, options?: any) {
        return QueryGraphApiFp(this.configuration).deleteGraphElementId(body, graphElementId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete the head term from the query graph.
     * @param {QueryGraph} body 
     * @param {string} headTerm The head term that should be delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryGraphApi
     */
    public deleteHeadTerm(body: QueryGraph, headTerm: string, options?: any) {
        return QueryGraphApiFp(this.configuration).deleteHeadTerm(body, headTerm, options)(this.fetch, this.basePath);
    }

    /**
     * Starting from only the clicked class get the query graph that will be rendered by Sparqling, the query head, the sparql code. The sparql query returned will be somthing like `select ?x { ?x a <clickedClassIRI>` }. The variable `?x` should be called according to the entity remainder or label. The variable will be added to the head of the query in order to create a valid SPARQL query.
     * @summary This is the first route to call in order to build the query graph.
     * @param {string} clickedClassIRI The IRI of the entity clicked on the GRAPHOLscape ontology graph
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryGraphApi
     */
    public getQueryGraph(clickedClassIRI: string, options?: any) {
        return QueryGraphApiFp(this.configuration).getQueryGraph(clickedClassIRI, options)(this.fetch, this.basePath);
    }

    /**
     * This route will return the same query graph passed in the body but the SPARQL code with the new filters optionals group by and havings. Note that if the filters are related to optional variables they should be put inside the optional block.
     * @summary Translate the query graph in sparql.
     * @param {QueryGraph} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryGraphApi
     */
    public modifyFilters(body: QueryGraph, options?: any) {
        return QueryGraphApiFp(this.configuration).modifyFilters(body, options)(this.fetch, this.basePath);
    }

    /**
     * This call is used when the user click on a highlighted class and should add a triple pattern of the form like `?x rdf:type <targetClassIRI>`. The server should find `?x` in the SPARQL code as the variable associated to the `sourceClassIRI`.
     * @summary Starting from the current query graph continue to build the query graph through a class.
     * @param {QueryGraph} body 
     * @param {string} graphElementId The id of the node of the selected class in the query graph.
     * @param {string} sourceClassIRI The IRI of the last selected class. It could be selected from the ontology graph or from the query graph.
     * @param {string} targetClassIRI The IRI of the entity clicked on the GRAPHOLscape ontology graph.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryGraphApi
     */
    public putQueryGraphClass(body: QueryGraph, graphElementId: string, sourceClassIRI: string, targetClassIRI: string, options?: any) {
        return QueryGraphApiFp(this.configuration).putQueryGraphClass(body, graphElementId, sourceClassIRI, targetClassIRI, options)(this.fetch, this.basePath);
    }

    /**
     * This route is used when the user click a highlighted data property. The triple pattern to add is something like `?x <predicateIRI> ?y` where `?x` should be derived from `selectedClassIRI`. Note that `?y` is fresh new variable that should be added also to the head of the query (we assume data property values are interesting). The variable `?y` should be called according to the entity remainder or label and should add a counter if there is an already defined variable for that data property.
     * @summary Starting from the current query graph continue to build the query graph through a data property.
     * @param {QueryGraph} body 
     * @param {string} graphElementId The id of the node of the selected class in the query graph.
     * @param {string} sourceClassIRI The IRI of the last selected class. It could be selected from the ontology graph or from the query graph.
     * @param {string} predicateIRI The IRI of the clicked data property.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryGraphApi
     */
    public putQueryGraphDataProperty(body: QueryGraph, graphElementId: string, sourceClassIRI: string, predicateIRI: string, options?: any) {
        return QueryGraphApiFp(this.configuration).putQueryGraphDataProperty(body, graphElementId, sourceClassIRI, predicateIRI, options)(this.fetch, this.basePath);
    }

    /**
     * Starting from a query graph which has two nodes representing the same class, it returns the query graph in which the two nodes have been joined into a single one. The children of the selected nodes will be grouped in `graphElementId1` and each time we add a children through the previous routes they will be added to this node.
     * @summary Join two GraphNodeElement in one. graph through a data property.
     * @param {QueryGraph} body 
     * @param {string} graphElementId1 The id of the node of the selected class in the query graph.
     * @param {string} graphElementId2 The id of the node of the selected class in the query graph.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryGraphApi
     */
    public putQueryGraphJoin(body: QueryGraph, graphElementId1: string, graphElementId2: string, options?: any) {
        return QueryGraphApiFp(this.configuration).putQueryGraphJoin(body, graphElementId1, graphElementId2, options)(this.fetch, this.basePath);
    }

    /**
     * This route is used when the user click a highlighted object property with ornly one `relatedClasses` or, in the case of more than one `relatedClasses` immediatly after choosing one of them. In this case the triple pattern to add is something like `?x <predicateIRI> ?y` where `?x` and `?y` should be derived from the direction indicated by `isPredicateDirect` of the object property with respect to `sourceClassIRI` and `targetClassIRI`. If there is a cyclic object property the user also should specify the direction if order to correctly assign `?x` and `?y`. Either `?x` or `?y` should be a fresh new variable which should be linked to a new triple pattern `?y rdf:type <targetClassIRI>`. The variable `?y` should be called according to the entity remainder or label and should add a counter if there is an already defined variable for that class.
     * @summary Starting from the current query graph continue to build the query graph through a object property.
     * @param {QueryGraph} body 
     * @param {string} graphElementId The id of the node of the selected class in the query graph.
     * @param {string} sourceClassIRI The IRI of the last selected class. It could be selected from the ontology graph or from the query graph.
     * @param {string} predicateIRI The IRI of the predicate which links source class and target class
     * @param {string} targetClassIRI The IRI of the entity clicked on the GRAPHOLscape ontology graph.
     * @param {boolean} isPredicateDirect If true sourceClassIRI is the domain of predicateIRI, if false sourceClassIRI is the range of predicateIRI.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryGraphApi
     */
    public putQueryGraphObjectProperty(body: QueryGraph, graphElementId: string, sourceClassIRI: string, predicateIRI: string, targetClassIRI: string, isPredicateDirect: boolean, options?: any) {
        return QueryGraphApiFp(this.configuration).putQueryGraphObjectProperty(body, graphElementId, sourceClassIRI, predicateIRI, targetClassIRI, isPredicateDirect, options)(this.fetch, this.basePath);
    }

}
/**
 * StandaloneApi - fetch parameter creator
 * @export
 */
export const StandaloneApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Return the graphol file as a string to be parsed by GRAPHOLscape.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        standaloneOntologyGrapholGet(options: any = {}): FetchArgs {
            const localVarPath = `/standalone/ontology/graphol`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Uploads a .graphol or .owl file. This will be used only by standalone Sparqling.
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        standaloneOntologyUploadPost(file?: Blob, options: any = {}): FetchArgs {
            const localVarPath = `/standalone/ontology/upload`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            if (file !== undefined) {
                localVarFormParams.set('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StandaloneApi - functional programming interface
 * @export
 */
export const StandaloneApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Return the graphol file as a string to be parsed by GRAPHOLscape.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        standaloneOntologyGrapholGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = StandaloneApiFetchParamCreator(configuration).standaloneOntologyGrapholGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Uploads a .graphol or .owl file. This will be used only by standalone Sparqling.
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        standaloneOntologyUploadPost(file?: Blob, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = StandaloneApiFetchParamCreator(configuration).standaloneOntologyUploadPost(file, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * StandaloneApi - factory interface
 * @export
 */
export const StandaloneApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Return the graphol file as a string to be parsed by GRAPHOLscape.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        standaloneOntologyGrapholGet(options?: any) {
            return StandaloneApiFp(configuration).standaloneOntologyGrapholGet(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Uploads a .graphol or .owl file. This will be used only by standalone Sparqling.
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        standaloneOntologyUploadPost(file?: Blob, options?: any) {
            return StandaloneApiFp(configuration).standaloneOntologyUploadPost(file, options)(fetch, basePath);
        },
    };
};

/**
 * StandaloneApi - object-oriented interface
 * @export
 * @class StandaloneApi
 * @extends {BaseAPI}
 */
export class StandaloneApi extends BaseAPI {
    /**
     * 
     * @summary Return the graphol file as a string to be parsed by GRAPHOLscape.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StandaloneApi
     */
    public standaloneOntologyGrapholGet(options?: any) {
        return StandaloneApiFp(this.configuration).standaloneOntologyGrapholGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Uploads a .graphol or .owl file. This will be used only by standalone Sparqling.
     * @param {Blob} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StandaloneApi
     */
    public standaloneOntologyUploadPost(file?: Blob, options?: any) {
        return StandaloneApiFp(this.configuration).standaloneOntologyUploadPost(file, options)(this.fetch, this.basePath);
    }

}
